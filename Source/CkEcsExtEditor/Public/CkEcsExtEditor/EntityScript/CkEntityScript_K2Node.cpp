#include "CkEntityScript_K2Node.h"

#include "CkCore/IO/CkIO_Utils.h"

#include "CkEcs/Subsystem/CkEcsWorld_Subsystem.h"

#include "CkEcsExt/EntityScript/CkEntityScript.h"
#include "CkEcsExt/EntityScript/CkEntityScript_Utils.h"

#include <GraphEditorSettings.h>

#include <Kismet/GameplayStatics.h>

#include <Kismet2/BlueprintEditorUtils.h>

#define LOCTEXT_NAMESPACE "UCk_K2Node_EntityScript"

// --------------------------------------------------------------------------------------------------------------------

namespace ck_k2node_entity_script
{
    static auto PinName_LifetimeOwner = TEXT("InLifetimeOwner");
    static auto PinName_Class  = TEXT("InEntityScriptClass");
    static auto PinName_LifetimeOwnerType  = TEXT("InLifetimeOwnerType");
}

auto
    UCk_K2Node_EntityScript::
    DoCreatePinsFromEntityScript(
        UClass* InEntityScriptClass)
    -> void
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return; }

    _PinsGeneratedForEntityScript.Empty();

    const auto& CreatePinFromProperty = [this](const FProperty* InProperty, const uint8* InContainer)
    {
        auto* Pin = CreatePin(EGPD_Input, NAME_None, InProperty->GetFName());
        _PinsGeneratedForEntityScript.Add(Pin);

        if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        Pin->PinFriendlyName = InProperty->GetDisplayNameText();
        const auto* K2Schema = GetDefault<UEdGraphSchema_K2>();

        K2Schema->ConvertPropertyToPinType(InProperty, Pin->PinType);

        if (K2Schema->PinDefaultValueIsEditable(*Pin))
        {
            auto DefaultValueAsString = FString{};
            const auto& DefaultValueSet = FBlueprintEditorUtils::PropertyValueToString(InProperty, InContainer, DefaultValueAsString, this);
            check(DefaultValueSet);

            K2Schema->SetPinAutogeneratedDefaultValue(Pin, DefaultValueAsString);
        }

        K2Schema->ConstructBasicPinTooltip(*Pin, InProperty->GetToolTipText(), Pin->PinToolTip);
    };

    const auto* ConstructionScriptCDO = InEntityScriptClass->GetDefaultObject();

    for (TFieldIterator<FProperty> PropertyIt(InEntityScriptClass, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
    {
        auto* Property = *PropertyIt;

        const auto& IsDelegate = Property->IsA(FMulticastDelegateProperty::StaticClass());
        const auto& IsExposedToSpawn = UEdGraphSchema_K2::IsPropertyExposedOnSpawn(Property);
        const auto& IsSettableExternally = NOT Property->HasAnyPropertyFlags(CPF_DisableEditOnInstance);

        if (Property->HasAnyPropertyFlags(CPF_Parm) ||
            NOT FBlueprintEditorUtils::PropertyStillExists(Property) ||
            NOT Property->HasAllPropertyFlags(CPF_BlueprintVisible) ||
            NOT IsSettableExternally ||
            NOT IsExposedToSpawn ||
            IsDelegate ||
            ck::IsValid(FindPin(Property->GetFName()), ck::IsValid_Policy_NullptrOnly{}))
        { continue; }

        CreatePinFromProperty(Property, reinterpret_cast<const uint8*>(ConstructionScriptCDO));
    }
}

auto
    UCk_K2Node_EntityScript::
    DoOnClassPinChanged()
    -> void
{
    TArray<UEdGraphPin*> OldPins = Pins;
    TArray<UEdGraphPin*> OldClassPins;

    for (auto* OldPin : OldPins)
    {
        if (NOT _PinsGeneratedForEntityScript.Contains(OldPin))
        { continue; }

        Pins.Remove(OldPin);
        OldClassPins.Add(OldPin);
    }

    TArray<UEdGraphPin*> NewClassPins;

    if (const auto& ClassPin = UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, Pins);
        ck::IsValid(ClassPin))
    {
        if (auto* ClassToSpawn = Cast<UClass>((*ClassPin)->DefaultObject);
            ck::IsValid(ClassToSpawn))
        {
            DoCreatePinsFromEntityScript(ClassToSpawn);
        }
    }

    RestoreSplitPins(OldPins);
    RewireOldPinsToNewPins(OldClassPins, Pins, nullptr);
    GetGraph()->NotifyGraphChanged();
    FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}

auto
    UCk_K2Node_EntityScript::
    IsNodePure() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    ReallocatePinsDuringReconstruction(
        TArray<UEdGraphPin*>& InOldPins)
    -> void
{
    // Now proceed with standard pin reallocation
    AllocateDefaultPins();

    // Get entity script class from old pins
    if (auto* EntityScriptClass = DoGet_EntityScriptClass(InOldPins))
    {
        DoCreatePinsFromEntityScript(EntityScriptClass);
    }

    RestoreSplitPins(InOldPins);
}

auto
    UCk_K2Node_EntityScript::
    ShouldShowNodeProperties() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    GetNodeTitle(
        ENodeTitleType::Type InTitleType) const
    -> FText
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::IsValid(EntityScriptClass))
    {
        return CK_UTILS_IO_GET_LOCTEXT
        (
            TEXT("UCk_K2Node_EntityScript"),
            *ck::Format_UE(TEXT("[Ck] Request Spawn Entity\n({})"), EntityScriptClass->GetDisplayNameText())
        );
    }

    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Request Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    GetIconAndTint(
        FLinearColor& OutColor) const
    -> FSlateIcon
{
    OutColor = GetDefault<UGraphEditorSettings>()->FunctionCallNodeTitleColor;
    return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Kismet.AllClasses.FunctionIcon"));
}

auto
    UCk_K2Node_EntityScript::
    GetMenuCategory() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("Ck|EntityScript")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoAllocate_DefaultPins()
    -> void
{
    using namespace ck_k2node_entity_script;

    CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Class,
        UCk_EntityScript_UE::StaticClass(),
        PinName_Class
    );

    auto* LifetimeOwnerTypeEnumPin =  CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Byte,
        StaticEnum<ECk_EntityLifetime_OwnerType>(),
        PinName_LifetimeOwnerType
    );

    const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
    Schema->SetPinAutogeneratedDefaultValueBasedOnType(LifetimeOwnerTypeEnumPin);

    _LifetimeOwnerType = DoGet_LifetimeOwnerType();

    DoCreatePinsFromEntityScript(DoGet_EntityScriptClass());
}

auto
    UCk_K2Node_EntityScript::
    IsCompatibleWithGraph(
        UEdGraph const* InGraph) const
    -> bool
{
    return Super::IsCompatibleWithGraph(InGraph);
}

auto
    UCk_K2Node_EntityScript::
    PinConnectionListChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::PinConnectionListChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        DoOnClassPinChanged();
    }
}

auto
    UCk_K2Node_EntityScript::
    GetPinMetaData(
        FName InPinName,
        FName InKey)
    -> FString
{
    if (InPinName == ck_k2node_entity_script::PinName_Class && InKey == FBlueprintMetadata::MD_AllowAbstractClasses)
    { return TEXT("False"); }

    return Super::GetPinMetaData(InPinName, InKey);
}

auto
    UCk_K2Node_EntityScript::
    PostReconstructNode()
    -> void
{
    Super::PostReconstructNode();

    if (const auto CurrentLifetimeOwnerType = DoGet_LifetimeOwnerType();
        _LifetimeOwnerType != CurrentLifetimeOwnerType)
    {
        _LifetimeOwnerType = CurrentLifetimeOwnerType;

        // Handle pin reconstruction based on the updated enum value
        const bool NeedsLifetimeOwnerPin = _LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseCustomEntity;
        const bool HasLifetimeOwnerPin = ck::IsValid(FindPin(ck_k2node_entity_script::PinName_LifetimeOwner), ck::IsValid_Policy_NullptrOnly{});

        if (NeedsLifetimeOwnerPin && NOT HasLifetimeOwnerPin)
        {
            auto PinParams = FCreatePinParams{};
            PinParams.Index = 4;

            CreatePin(
                EGPD_Input,
                UEdGraphSchema_K2::PC_Struct,
                FCk_Handle::StaticStruct(),
                ck_k2node_entity_script::PinName_LifetimeOwner,
                PinParams
            );

            GetGraph()->NotifyGraphChanged();
        }
        else if (NOT NeedsLifetimeOwnerPin && HasLifetimeOwnerPin)
        {
            RemovePin(FindPin(ck_k2node_entity_script::PinName_LifetimeOwner));
            GetGraph()->NotifyGraphChanged();
        }
    }
}

auto
    UCk_K2Node_EntityScript::
    DoExpandNode(
        FKismetCompilerContext& InCompilerContext,
        UEdGraph* InSourceGraph,
        ECk_ValidInvalid InNodeValidity)
    -> void
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script", "Invalid Entity Script. @@").ToString(), this);
        return;
    }

    _LifetimeOwnerType = DoGet_LifetimeOwnerType();

    // Set up the 'SpawnObject' function node
    auto* SpawnObject_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    SpawnObject_Node->FunctionReference.SetExternalMember
    (
        GET_FUNCTION_NAME_CHECKED(UGameplayStatics, SpawnObject),
        UGameplayStatics::StaticClass()
    );
    SpawnObject_Node->AllocateDefaultPins();
    InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(SpawnObject_Node, this);

    if (auto* ObjectClassPin = SpawnObject_Node->FindPin(TEXT("ObjectClass"));
        ck::IsValid(ObjectClassPin, ck::IsValid_Policy_NullptrOnly{}))
    {
        InCompilerContext.GetSchema()->TrySetDefaultValue(*ObjectClassPin, EntityScriptClass->GetClassPathName().ToString());
        UCk_Utils_EditorGraph_UE::Request_ForceRefreshNode(*SpawnObject_Node);
    }

    const auto& SpawnObjectResultPin  = UCk_Utils_EditorGraph_UE::Get_Pin_Result(*SpawnObject_Node);

    if (ck::IsValid(SpawnObjectResultPin))
    {
        (*SpawnObjectResultPin)->PinType.PinSubCategoryObject = EntityScriptClass->GetAuthoritativeClass();
    }

    // Link the 'N' SetByVar nodes that were spawned for each properties different from the CDO
    auto* LastThenFollowingSetByVarPin = FKismetCompilerUtilities::GenerateAssignmentNodes
    (
        InCompilerContext,
        InSourceGraph,
        SpawnObject_Node,
        this,
        *SpawnObjectResultPin,
        EntityScriptClass
    );

    // Set up 'Request_SpawnEntity' function node
    auto* SpawnEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    SpawnEntity_Node->FunctionReference.SetExternalMember
    (
        GET_FUNCTION_NAME_CHECKED(UCk_Utils_EntityScript_UE, Request_SpawnEntity),
        UCk_Utils_EntityScript_UE::StaticClass()
    );
    SpawnEntity_Node->AllocateDefaultPins();
    InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(SpawnEntity_Node, this);

    // Connect everything together
    if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
    (
        InCompilerContext,
        {
            {
                LastThenFollowingSetByVarPin,
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*SpawnEntity_Node),
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*SpawnObject_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InEntityScript"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            },
        }
    ) == ECk_SucceededFailed::Failed) { return; }

    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*SpawnObject_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*SpawnEntity_Node)
            },
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed) { return; }

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseTransientEntity)
    {
        // Set up 'Get_TransientEntity' function node
        auto* GetTransientEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
        GetTransientEntity_Node->FunctionReference.SetExternalMember
        (
            GET_FUNCTION_NAME_CHECKED(UCk_Utils_EcsWorld_Subsystem_UE, Get_TransientEntity_FromContextObject),
            UCk_Utils_EcsWorld_Subsystem_UE::StaticClass()
        );
        GetTransientEntity_Node->AllocateDefaultPins();
        InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(GetTransientEntity_Node, this);

        if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin_Result(*GetTransientEntity_Node),
                    UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InLifetimeOwner"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
                },
            }
        ) == ECk_SucceededFailed::Failed) { return; }
    }
    else
    {
        if (UCk_Utils_EditorGraph_UE::Request_LinkPins
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_LifetimeOwner, ECk_EditorGraph_PinDirection::Input, *this),
                    SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_LifetimeOwner)
                },
            },
            ECk_EditorGraph_PinLinkType::Move
        ) == ECk_SucceededFailed::Failed) { return; }
    }

    BreakAllNodeLinks();
}

auto
    UCk_K2Node_EntityScript::
    DoGet_Menu_NodeTitle() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoPinDefaultValueChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::DoPinDefaultValueChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
    {
        if (const auto NewLifetimeOwnerType = DoGet_LifetimeOwnerType();
            _LifetimeOwnerType != NewLifetimeOwnerType)
        {
            _LifetimeOwnerType = NewLifetimeOwnerType;
            ReconstructNode();
        }
        return;
    }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        auto* EntityScriptClass = Cast<UClass>(InPin->DefaultObject);

        const auto& CheckPinValidity = [&]() -> ECk_SucceededFailed
        {
            if (ck::Is_NOT_Valid(EntityScriptClass))
            { return ECk_SucceededFailed::Failed; }

            CK_ENSURE_IF_NOT(NOT EntityScriptClass->HasAnyClassFlags(_DisallowedFlags), TEXT("The DefaultObject in the [{}] pin cannot be an Abstract/Deprecated/None class."), InPin->PinName)
            { return ECk_SucceededFailed::Failed; }

            return ECk_SucceededFailed::Succeeded;
        };

        if (CheckPinValidity() == ECk_SucceededFailed::Failed)
        {
            InPin->DefaultObject = nullptr;
        }

        DoOnClassPinChanged();
        return;
    }
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntityScriptClass(
        TOptional<TArray<UEdGraphPin*>> InPinsToSearch) const
    -> UClass*
{
    if (ck::Is_NOT_Valid(InPinsToSearch))
    {
        InPinsToSearch = Pins;
    }

    const auto& ClassPin = UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *InPinsToSearch);

    if (ck::Is_NOT_Valid(ClassPin))
    { return {}; }

    const auto& ClassPinCDO = (*ClassPin)->DefaultObject;
    const auto& ClassPinLinkedTo = (*ClassPin)->LinkedTo;

    if (ClassPinLinkedTo.Num() == 0)
    {
        return ck::IsValid(ClassPinCDO) ? CastChecked<UClass>(ClassPinCDO) : nullptr;
    }

    const auto& ClassSource = ClassPinLinkedTo[0];
    return  ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
}

auto
    UCk_K2Node_EntityScript::
    DoGet_LifetimeOwnerType() const
    -> ECk_EntityLifetime_OwnerType
{
    return *UCk_Utils_EditorGraph_UE::Get_Pin_EnumValue<ECk_EntityLifetime_OwnerType>(
        ck_k2node_entity_script::PinName_LifetimeOwnerType, ECk_EditorGraph_PinDirection::Input, *this);;
}

// --------------------------------------------------------------------------------------------------------------------

#undef LOCTEXT_NAMESPACE