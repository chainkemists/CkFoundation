#include "CkEntityScript_K2Node.h"

#include "CkCore/EditorOnly/CkEditorOnly_Utils.h"
#include "CkCore/IO/CkIO_Utils.h"
#include "CkCore/Object/CkObject_Utils.h"
#include "CkCore/Reflection/CkReflection_Utils.h"

#include "CkEcs/EntityScript/CkEntityScript.h"
#include "CkEcs/EntityScript/CkEntityScript_Utils.h"
#include "CkEcs/Subsystem/CkEcsWorld_Subsystem.h"
#include "CkEcs/Subsystem/CkEntityScript_Subsystem.h"

#include <GraphEditorSettings.h>
#include <K2Node_MakeStruct.h>
#include <Kismet/GameplayStatics.h>
#include <Kismet/BlueprintInstancedStructLibrary.h>
#include <Kismet2/BlueprintEditorUtils.h>
#include <K2Node_CallFunction.h>
#include <K2Node_MakeStruct.h>
#include <EditorStyleSet.h>
#include <Widgets/Input/SButton.h>
#include <Widgets/Text/STextBlock.h>
#include <Widgets/Layout/SBox.h>
#include <Framework/Notifications/NotificationManager.h>
#include <Widgets/Notifications/SNotificationList.h>

#define LOCTEXT_NAMESPACE "UCk_K2Node_EntityScript"

// --------------------------------------------------------------------------------------------------------------------

// ReSharper disable once CppInconsistentNaming
namespace ck_k2node_entity_script
{
    static auto PinName_LifetimeOwner = TEXT("InLifetimeOwner");
    static auto PinName_Class  = TEXT("InEntityScriptClass");
    static auto PinName_LifetimeOwnerType  = TEXT("InLifetimeOwnerType");
    static auto PinName_ReturnValue  = TEXT("EntityUnderConstruction");
}

auto
    UCk_K2Node_EntityScript::
    DoCreatePinsFromEntityScript(
        UClass* InEntityScriptClass)
    -> void
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return; }

    _PinsGeneratedForEntityScript.Reset();
    _PinMetadataMap.Reset();
    AdvancedPinDisplay = ENodeAdvancedPins::Type::NoPins;

    const auto& CreatePinFromProperty = [this](const FProperty* InProperty, UObject* InContainer)
    {
        auto* Pin = CreatePin(EGPD_Input, NAME_None, InProperty->GetFName());
        _PinsGeneratedForEntityScript.Add(Pin);

        if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        Pin->PinFriendlyName = InProperty->GetDisplayNameText();

        const auto& ShowInAdvancedDisplay = InProperty->HasAllPropertyFlags(CPF_AdvancedDisplay);
        Pin->bAdvancedView = ShowInAdvancedDisplay;
        if (ShowInAdvancedDisplay && (ENodeAdvancedPins::NoPins == AdvancedPinDisplay))
        {
            AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
        }

        const auto* K2Schema = GetDefault<UEdGraphSchema_K2>();

        K2Schema->ConvertPropertyToPinType(InProperty, Pin->PinType);

        if (K2Schema->PinDefaultValueIsEditable(*Pin))
        {
            auto DefaultValueAsString = FString{};
            const auto& DefaultValueSet = FBlueprintEditorUtils::PropertyValueToString(InProperty, reinterpret_cast<const uint8*>(InContainer), DefaultValueAsString, this);
            check(DefaultValueSet);

            K2Schema->SetPinAutogeneratedDefaultValue(Pin, DefaultValueAsString);
        }
        else if (const auto* StructProperty = CastField<FStructProperty>(InProperty);
                 ck::IsValid(StructProperty))
        {
            if (const auto* StructData = InProperty->ContainerPtrToValuePtr<uint8>(InContainer))
            {
                FString DefaultStructValue;
                StructProperty->Struct->ExportText(
                    DefaultStructValue,
                    StructData,
                    StructData,
                    InContainer,
                    PPF_None,
                    nullptr);

                K2Schema->TrySetDefaultValue(*Pin, DefaultStructValue);
            }
        }

        K2Schema->ConstructBasicPinTooltip(*Pin, InProperty->GetToolTipText(), Pin->PinToolTip);

        if (const auto* MetaDataMap = InProperty->GetMetaDataMap())
        {
            for (const auto& MetaDataKvp : *MetaDataMap)
            {
                _PinMetadataMap.FindOrAdd(Pin->PinName).Add(MetaDataKvp.Key, MetaDataKvp.Value);
            }
        }
    };

    auto* ConstructionScriptCDO = InEntityScriptClass->GetDefaultObject();

    for (const auto* ExposedProperty : UCk_Utils_Reflection_UE::Get_ExposedPropertiesOfClass(InEntityScriptClass))
    {
        CreatePinFromProperty(ExposedProperty, ConstructionScriptCDO);
    }
}

auto
    UCk_K2Node_EntityScript::
    DoOnClassPinChanged()
    -> void
{
    TArray<UEdGraphPin*> OldPins = Pins;
    TArray<UEdGraphPin*> OldClassPins;

    for (auto* OldPin : OldPins)
    {
        if (NOT _PinsGeneratedForEntityScript.Contains(OldPin))
        { continue; }

        Pins.Remove(OldPin);
        OldClassPins.Add(OldPin);
    }

    TArray<UEdGraphPin*> NewClassPins;

    if (auto* ClassToSpawn = DoGet_EntityScriptClass(Pins);
        ck::IsValid(ClassToSpawn))
    {
        DoCreatePinsFromEntityScript(ClassToSpawn);
    }

    RestoreSplitPins(OldPins);
    RewireOldPinsToNewPins(OldClassPins, Pins, nullptr);
    GetGraph()->NotifyGraphChanged();
    FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}

auto
    UCk_K2Node_EntityScript::
    IsNodePure() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    ReallocatePinsDuringReconstruction(
        TArray<UEdGraphPin*>& InOldPins)
    -> void
{
    for (const auto Pin : InOldPins)
    {
        if (Pin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
        {
            const auto EnumValue = UCk_Utils_Enum_UE::Get_EnumFromString<ECk_EntityLifetime_OwnerType>(Pin->DefaultValue);
            CK_ENSURE_IF_NOT(ck::IsValid(EnumValue),
                TEXT("Failed to get Enum value from string [{}]. This should have worked. Some EntityScript Spawn nodes in the graph [{}] might be faulty."),
                Pin->DefaultValue, this->GetGraph())
            { break; }

            _LifetimeOwnerType = *EnumValue;
            break;
        }
    }

    // Now proceed with standard pin reallocation
    AllocateDefaultPins();

    // Get entity script class from old pins
    if (auto* EntityScriptClass = DoGet_EntityScriptClass(InOldPins))
    {
        DoCreatePinsFromEntityScript(EntityScriptClass);
    }

    RestoreSplitPins(InOldPins);
}

auto
    UCk_K2Node_EntityScript::
    ShouldShowNodeProperties() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    GetNodeTitle(
        ENodeTitleType::Type InTitleType) const
    -> FText
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass();
        ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =  UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();
        const auto& InstancingPolicy = EntityScriptCDO->Get_InstancingPolicy();

        return CK_UTILS_IO_GET_LOCTEXT
        (
            TEXT("UCk_K2Node_EntityScript"),
            *ck::Format_UE(TEXT("[Ck] Spawn {}\n{} - {}"),
                EntityScriptClass->GetDisplayNameText(),
                Replication == ECk_Replication::Replicates ? TEXT("Replicated" : TEXT("Local")),
                InstancingPolicy == ECk_EntityScript_InstancingPolicy::NotInstanced ? TEXT("CDO" : TEXT("Instanced")))
        );
    }

    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Request Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    GetIconAndTint(
        FLinearColor& OutColor) const
    -> FSlateIcon
{
    OutColor = GetDefault<UGraphEditorSettings>()->FunctionCallNodeTitleColor;
    return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Kismet.AllClasses.FunctionIcon"));
}

auto
    UCk_K2Node_EntityScript::
    GetReplicationIcon() const
    -> FSlateIcon
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass(); ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =
            UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();

        if (Replication == ECk_Replication::Replicates)
        {
            // Use network/multiplayer icon
            return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Icons.Network"));
        }
        else
        {
            // Use local/single player icon
            return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Icons.Computer"));
        }
    }

    return FSlateIcon();
}

auto
    UCk_K2Node_EntityScript::
    GetMenuCategory() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("Ck|EntityScript")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoAllocate_DefaultPins()
    -> void
{
    using namespace ck_k2node_entity_script;

    CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Class,
        UCk_EntityScript_UE::StaticClass(),
        PinName_Class
    );

    auto* LifetimeOwnerTypeEnumPin =  CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Byte,
        StaticEnum<ECk_EntityLifetime_OwnerType>(),
        PinName_LifetimeOwnerType
    );

    auto* ReturnValuePin = CreatePin
    (
        EGPD_Output,
        UEdGraphSchema_K2::PC_Struct,
        FCk_Handle_PendingEntityScript::StaticStruct(),
        PinName_ReturnValue
    );
    ReturnValuePin->PinToolTip = TEXT("The handle to the newly spawned Entity (not yet constructed)");

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseCustomEntity)
    {
        CreatePin(
            EGPD_Input,
            UEdGraphSchema_K2::PC_Struct,
            FCk_Handle::StaticStruct(),
            PinName_LifetimeOwner
        );
    }

    const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
    Schema->SetPinAutogeneratedDefaultValueBasedOnType(LifetimeOwnerTypeEnumPin);

    DoCreatePinsFromEntityScript(DoGet_EntityScriptClass());
}

auto
    UCk_K2Node_EntityScript::
    IsCompatibleWithGraph(
        UEdGraph const* InGraph) const
    -> bool
{
    return Super::IsCompatibleWithGraph(InGraph);
}

auto
    UCk_K2Node_EntityScript::
    PinConnectionListChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::PinConnectionListChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        DoOnClassPinChanged();
    }
}

auto
    UCk_K2Node_EntityScript::
    GetPinMetaData(
        FName InPinName,
        FName InKey)
    -> FString
{
    if (InPinName == ck_k2node_entity_script::PinName_Class && InKey == FBlueprintMetadata::MD_AllowAbstractClasses)
    { return TEXT("False"); }

    if (const TMap<FName, FString>* Metadata = _PinMetadataMap.Find(InPinName))
    {
        if (const FString* Value = Metadata->Find(InKey))
        {
            return *Value;
        }
    }

    return Super::GetPinMetaData(InPinName, InKey);
}

auto
    UCk_K2Node_EntityScript::
    GetJumpTargetForDoubleClick() const
    -> UObject*
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    { return Super::GetJumpTargetForDoubleClick(); }

    return UCk_Utils_Object_UE::Get_ClassGeneratedByBlueprint(EntityScriptClass);
}

auto
    UCk_K2Node_EntityScript::
    CreateVisualWidget()
    -> TSharedPtr<SGraphNode>
{
    return SNew(SCk_GraphNode_EntityScript, this);
}

auto
    UCk_K2Node_EntityScript::
    OnInterfacePinButtonClicked(FName PinName) const
    -> void
{
    auto* ClickedPin = FindPin(PinName);
    if (ck::Is_NOT_Valid(ClickedPin, ck::IsValid_Policy_NullptrOnly{}) || NOT IsInterfacePin(ClickedPin))
    { return; }

    if (ClickedPin->Direction != EGPD_Input)
    { return; }

    UClass* InterfaceClass = nullptr;
    if (ClickedPin->PinType.PinSubCategoryObject.IsValid())
    {
        InterfaceClass = Cast<UClass>(ClickedPin->PinType.PinSubCategoryObject.Get());
    }

    if (ck::Is_NOT_Valid(InterfaceClass) || NOT InterfaceClass->HasAnyClassFlags(CLASS_Interface))
    {
        auto NotificationInfo = FNotificationInfo(FText::FromString(TEXT("Invalid interface class for pin")));
        NotificationInfo.ExpireDuration = 3.0f;
        NotificationInfo.bFireAndForget = true;
        FSlateNotificationManager::Get().AddNotification(NotificationInfo);
        return;
    }

    auto* Blueprint = GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    {
        FNotificationInfo NotificationInfo(FText::FromString(TEXT("Could not find blueprint to implement interface")));
        NotificationInfo.ExpireDuration = 3.0f;
        NotificationInfo.bFireAndForget = true;
        FSlateNotificationManager::Get().AddNotification(NotificationInfo);
        return;
    }

    if (const auto& Success = UCk_Utils_EditorOnly_UE::Request_ImplementNewInterface(Blueprint, InterfaceClass);
        Success == ECk_SucceededFailed::Failed)
    { return; }

    auto NotificationInfo = FNotificationInfo(FText::FromString(ck::Format_UE(TEXT("Implemented interface: {}"), InterfaceClass->GetName())));
    NotificationInfo.ExpireDuration = 3.0f;
    NotificationInfo.bFireAndForget = true;
    FSlateNotificationManager::Get().AddNotification(NotificationInfo);

    FBlueprintEditorUtils::MarkBlueprintAsModified(Blueprint);
}

auto
    UCk_K2Node_EntityScript::
    IsInterfacePin(
        UEdGraphPin* Pin)
    -> bool
{
    if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
    { return false; }

    if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Interface)
    { return true; }

    if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Class &&
        Pin->PinType.PinSubCategoryObject.IsValid())
    {
        if (const auto* Class = Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get());
            ck::IsValid(Class))
        {
            return Class->HasAnyClassFlags(CLASS_Interface);
        }
    }

    return false;
}

auto
    UCk_K2Node_EntityScript::
    IsPinGeneratedFromEntityScript(UEdGraphPin* Pin) const
    -> bool
{
    return _PinsGeneratedForEntityScript.Contains(Pin);
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntitySpawnParamsStruct(
        UClass* InEntityScriptClass,
        FKismetCompilerContext& InCompilerContext)
        -> UScriptStruct*
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return {}; }

    auto* EntityScriptSubsystem = GEngine->GetEngineSubsystem<UCk_EntityScript_Subsystem_UE>();
    if (ck::Is_NOT_Valid(EntityScriptSubsystem))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to get Entity Script Subsystem"));
        return {};
    }

    auto* SpawnParamsStruct = EntityScriptSubsystem->GetOrCreate_SpawnParamsStructForEntity(InEntityScriptClass);
    if (ck::Is_NOT_Valid(SpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to find valid Spawn Params struct for Entity Script [{}]"), InEntityScriptClass);
        return {};
    }

    return SpawnParamsStruct;
}

auto
    UCk_K2Node_EntityScript::
    DoExpandNode(
        FKismetCompilerContext& InCompilerContext,
        UEdGraph* InSourceGraph,
        ECk_ValidInvalid InNodeValidity)
    -> void
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script", "Invalid Entity Script. @@").ToString(), this);
        return;
    }

    if (EntityScriptClass == UCk_EntityScript_UE::StaticClass())
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Trying to Spawn Base Entity Script", "Cannot Spawn Base Entity Script. @@").ToString(), this);
        return;
    }

    _LifetimeOwnerType = DoGet_LifetimeOwnerType();

    auto* EntitySpawnParamsStruct = DoGet_EntitySpawnParamsStruct(EntityScriptClass, InCompilerContext);

    if (ck::Is_NOT_Valid(EntitySpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script Spawn Params struct", "Invalid Entity Script Spawn Params struct @@").ToString(), this);
        return;
    }

    // Create a Make Struct node for the Spawn Params
    auto* MakeSpawnParamsStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_MakeStruct>(this, InSourceGraph);
    MakeSpawnParamsStruct_Node->StructType = EntitySpawnParamsStruct;
    MakeSpawnParamsStruct_Node->bMadeAfterOverridePinRemoval = true;
    MakeSpawnParamsStruct_Node->AllocateDefaultPins();

    // Create a MakeInstancedStruct node to convert UScriptStruct to FInstancedStruct
    auto* MakeInstancedStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    MakeInstancedStruct_Node->SetFromFunction(UBlueprintInstancedStructLibrary::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UBlueprintInstancedStructLibrary, MakeInstancedStruct)));
    MakeInstancedStruct_Node->AllocateDefaultPins();

    const auto& TryCopyValueOrLinkPin = [&](UEdGraphPin* InPinToCopyOrLinkFrom)
    {
        auto* FoundMakeStructPin = MakeSpawnParamsStruct_Node->FindPinByPredicate([&](const UEdGraphPin* InPin)
        {
            return InPin->PinFriendlyName.ToString() == InPinToCopyOrLinkFrom->PinName.ToString();
        });

        if (ck::Is_NOT_Valid(FoundMakeStructPin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        if (NOT InPinToCopyOrLinkFrom->DefaultValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultValue = InPinToCopyOrLinkFrom->DefaultValue;
        }

        if (ck::IsValid(InPinToCopyOrLinkFrom->DefaultObject))
        {
            FoundMakeStructPin->DefaultObject = InPinToCopyOrLinkFrom->DefaultObject;
        }

        if (NOT InPinToCopyOrLinkFrom->DefaultTextValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultTextValue = InPinToCopyOrLinkFrom->DefaultTextValue;
        }

        if (NOT InPinToCopyOrLinkFrom->LinkedTo.IsEmpty())
        {
            for (auto* LinkedPin : InPinToCopyOrLinkFrom->LinkedTo)
            {
                InCompilerContext.GetSchema()->TryCreateConnection(LinkedPin, FoundMakeStructPin);
            }
        }
    };

    for (auto* Pin : this->Pins)
    {
        if (Pin->Direction == EGPD_Input &&
            Pin != this->GetExecPin() &&
            Pin->PinName != ck_k2node_entity_script::PinName_Class &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwnerType &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwner)
        {
            TryCopyValueOrLinkPin(Pin);
        }
    }

    // Set up 'Request_SpawnEntity' function node
    auto* SpawnEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    SpawnEntity_Node->FunctionReference.SetExternalMember
    (
        GET_FUNCTION_NAME_CHECKED(UCk_Utils_EntityScript_UE, Request_SpawnEntity),
        UCk_Utils_EntityScript_UE::StaticClass()
    );
    SpawnEntity_Node->AllocateDefaultPins();
    InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(SpawnEntity_Node, this);

    // Connect everything together
    if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(EntitySpawnParamsStruct->GetFName(), ECk_EditorGraph_PinDirection::Output, *MakeSpawnParamsStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("Value"), ECk_EditorGraph_PinDirection::Input, *MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*SpawnEntity_Node),
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InSpawnParams"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            },
        }
    ) == ECk_SucceededFailed::Failed) { return; }

    // Link or assign entity script class
    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InEntityScriptClass"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed)
    {
        if (auto* EntityScriptClassPin = SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_Class);
            ck::IsValid(EntityScriptClassPin, ck::IsValid_Policy_NullptrOnly{}))
        {
            InCompilerContext.GetSchema()->TrySetDefaultValue(*EntityScriptClassPin, EntityScriptClass->GetClassPathName().ToString());
            UCk_Utils_EditorGraph_UE::Request_ForceRefreshNode(*SpawnEntity_Node);
        }
    }

    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*SpawnEntity_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_ReturnValue, ECk_EditorGraph_PinDirection::Output, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed) { return; }

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseTransientEntity)
    {
        // Set up 'Get_TransientEntity' function node
        auto* GetTransientEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
        GetTransientEntity_Node->FunctionReference.SetExternalMember
        (
            GET_FUNCTION_NAME_CHECKED(UCk_Utils_EcsWorld_Subsystem_UE, Get_TransientEntity_FromContextObject),
            UCk_Utils_EcsWorld_Subsystem_UE::StaticClass()
        );
        GetTransientEntity_Node->AllocateDefaultPins();
        InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(GetTransientEntity_Node, this);

        if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin_Result(*GetTransientEntity_Node),
                    UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InLifetimeOwner"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
                },
            }
        ) == ECk_SucceededFailed::Failed) { return; }
    }
    else
    {
        if (UCk_Utils_EditorGraph_UE::Request_LinkPins
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_LifetimeOwner, ECk_EditorGraph_PinDirection::Input, *this),
                    SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_LifetimeOwner, EGPD_Input)
                },
            },
            ECk_EditorGraph_PinLinkType::Move
        ) == ECk_SucceededFailed::Failed) { return; }
    }

    BreakAllNodeLinks();
}

auto
    UCk_K2Node_EntityScript::
    DoGet_Menu_NodeTitle() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoPinDefaultValueChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::DoPinDefaultValueChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
    {
        if (const auto NewLifetimeOwnerType = DoGet_LifetimeOwnerType();
            _LifetimeOwnerType != NewLifetimeOwnerType)
        {
            _LifetimeOwnerType = NewLifetimeOwnerType;
            ReconstructNode();
        }
        return;
    }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        auto* EntityScriptClass = Cast<UClass>(InPin->DefaultObject);

        const auto& CheckPinValidity = [&]() -> ECk_SucceededFailed
        {
            if (ck::Is_NOT_Valid(EntityScriptClass))
            { return ECk_SucceededFailed::Failed; }

            CK_ENSURE_IF_NOT(NOT EntityScriptClass->HasAnyClassFlags(_DisallowedFlags), TEXT("The DefaultObject in the [{}] pin cannot be an Abstract/Deprecated/None class."), InPin->PinName)
            { return ECk_SucceededFailed::Failed; }

            return ECk_SucceededFailed::Succeeded;
        };

        if (CheckPinValidity() == ECk_SucceededFailed::Failed)
        {
            InPin->DefaultObject = nullptr;
        }

        DoOnClassPinChanged();
        return;
    }
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntityScriptClass(
        TOptional<TArray<UEdGraphPin*>> InPinsToSearch) const
    -> UClass*
{
    if (ck::Is_NOT_Valid(InPinsToSearch))
    {
        InPinsToSearch = Pins;
    }

    const auto& ClassPin = UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *InPinsToSearch);

    if (ck::Is_NOT_Valid(ClassPin))
    { return {}; }

    const auto& ClassPinCDO = (*ClassPin)->DefaultObject;
    const auto& ClassPinLinkedTo = (*ClassPin)->LinkedTo;

    if (ClassPinLinkedTo.Num() == 0)
    {
        return ck::IsValid(ClassPinCDO) ? CastChecked<UClass>(ClassPinCDO) : nullptr;
    }

    const auto& ClassSource = ClassPinLinkedTo[0];
    return  ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
}

auto
    UCk_K2Node_EntityScript::
    DoGet_LifetimeOwnerType() const
    -> ECk_EntityLifetime_OwnerType
{
    return *UCk_Utils_EditorGraph_UE::Get_Pin_EnumValue<ECk_EntityLifetime_OwnerType>(
        ck_k2node_entity_script::PinName_LifetimeOwnerType, ECk_EditorGraph_PinDirection::Input, *this);
}

// --------------------------------------------------------------------------------------------------------------------

auto
    SCk_GraphPin_Interface::
    Construct(
        const FArguments& InArgs,
        UEdGraphPin* InPin)
    -> void
{
    SGraphPin::Construct(SGraphPin::FArguments(), InPin);
}

auto
    SCk_GraphPin_Interface::
    GetDefaultValueWidget()
    -> TSharedRef<SWidget>
{
    const auto& IsAlreadyImplemented = IsInterfaceAlreadyImplemented();

    // Instead of using the original widget, let's create our own integrated version
    return SNew(SHorizontalBox)
        + SHorizontalBox::Slot()
        .FillWidth(1.0f)
        .VAlign(VAlign_Center)
        [
            // Create a simple text block for the pin value instead of using the original widget
            SNew(STextBlock)
            .Text_Lambda([this]()
            {
                if (GraphPinObj && GraphPinObj->PinType.PinSubCategoryObject.IsValid())
                {
                    if (const auto* InterfaceClass = Cast<UClass>(GraphPinObj->PinType.PinSubCategoryObject.Get()))
                    {
                        return FText::FromString(InterfaceClass->GetName());
                    }
                }
                return FText::FromString(TEXT("None"));
            })
            .ColorAndOpacity(FLinearColor{0.1f, 0.1f, 0.1f, 1.0f})
            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 9))
        ]
        + SHorizontalBox::Slot()
        .AutoWidth()
        .VAlign(VAlign_Center)
        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
        [
            SNew(SBox)
            .WidthOverride(18.0f)
            .HeightOverride(18.0f)
            [
                SNew(SButton)
                .ButtonStyle(FAppStyle::Get(), "HoverHintOnly")
                .ForegroundColor(FSlateColor::UseForeground())
                .OnClicked(this, &SCk_GraphPin_Interface::OnImplementInterfaceClicked)
                .IsEnabled(NOT IsAlreadyImplemented)
                .ToolTipText(IsAlreadyImplemented ?
                    FText::FromString(TEXT("Interface already implemented in the current blueprint")) :
                    FText::FromString(TEXT("Implement this interface in the current blueprint")))
                .Content()
                [
                    SNew(STextBlock)
                    .Text(FText::FromString(IsAlreadyImplemented ? TEXT("●") : TEXT("+")))
                    .Font(FCoreStyle::GetDefaultFontStyle("Bold", 10))
                    .Justification(ETextJustify::Center)
                    .ColorAndOpacity(IsAlreadyImplemented ? FColor::Cyan : FColor::Green)
                ]
            ]
        ];
}

auto
    SCk_GraphPin_Interface::
    OnImplementInterfaceClicked() const
    -> FReply
{
    if (const auto& EntityScriptNode = Get_EntityScriptNode();
        ck::IsValid(EntityScriptNode))
    {
        EntityScriptNode->OnInterfacePinButtonClicked(GraphPinObj->PinName);
    }

    return FReply::Handled();
}

auto
    SCk_GraphPin_Interface::
    Get_InterfaceClass() const
    -> UClass*
{
    if (ck::Is_NOT_Valid(GraphPinObj, ck::IsValid_Policy_NullptrOnly{}) || ck::Is_NOT_Valid(GraphPinObj->PinType.PinSubCategoryObject))
    { return {}; }

    return Cast<UClass>(GraphPinObj->PinType.PinSubCategoryObject.Get());
}

auto
    SCk_GraphPin_Interface::
    IsInterfaceAlreadyImplemented() const
    -> bool
{
    auto* InterfaceClass = Get_InterfaceClass();
    if (ck::Is_NOT_Valid(GraphPinObj, ck::IsValid_Policy_NullptrOnly{}) || NOT InterfaceClass->HasAnyClassFlags(CLASS_Interface))
    { return {}; }

    const auto* EntityScriptNode = Get_EntityScriptNode();
    if (ck::Is_NOT_Valid(EntityScriptNode))
    { return {}; }

    const auto* Blueprint = EntityScriptNode->GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    { return {}; }

    return UCk_Utils_EditorOnly_UE::Get_DoesBlueprintImplementInterface(Blueprint, InterfaceClass);
}

auto
    SCk_GraphPin_Interface::
    Get_EntityScriptNode() const
    -> UCk_K2Node_EntityScript*
{
    if (GraphPinObj && GraphPinObj->GetOuter())
    {
        return Cast<UCk_K2Node_EntityScript>(GraphPinObj->GetOuter());
    }
    return nullptr;
}

// --------------------------------------------------------------------------------------------------------------------

auto
    SCk_GraphNode_EntityScript::
    Construct(
        const FArguments& InArgs,
        UCk_K2Node_EntityScript* InNode)
    -> void
{
    GraphNode = InNode;
    _EntityScriptNode = CastChecked<UCk_K2Node_EntityScript>(InNode);

    UpdateGraphNode();
}

auto
    SCk_GraphNode_EntityScript::
    CreatePinWidgets()
    -> void
{
    for (auto PinIt = GraphNode->Pins.CreateConstIterator(); PinIt; ++PinIt)
    {
        auto* CurrentPin = *PinIt;

        if (CurrentPin->bHidden)
        { continue; }

        if (auto NewPin = ShouldPinHaveInterfaceButton(CurrentPin) ? SNew(SCk_GraphPin_Interface, CurrentPin) : CreatePinWidget(CurrentPin);
            NewPin.IsValid())
        {
            this->AddPin(NewPin.ToSharedRef());
        }
    }
}

auto
    SCk_GraphNode_EntityScript::
    ShouldPinHaveInterfaceButton(
        UEdGraphPin* Pin) const
    -> bool
{
    if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}) || Pin->Direction != EGPD_Input || ck::Is_NOT_Valid(_EntityScriptNode))
    { return {}; }

    // Only add buttons to pins that are:
    // 1. Generated from EntityScript
    // 2. Are interface type pins
    return _EntityScriptNode->IsPinGeneratedFromEntityScript(Pin) &&
           _EntityScriptNode->IsInterfacePin(Pin);
}

auto
    SCk_GraphNode_EntityScript::
    CreateBelowPinControls(
        TSharedPtr<SVerticalBox> MainBox)
    -> void
{
    SGraphNode::CreateBelowPinControls(MainBox);

    if (ck::IsValid(_EntityScriptNode))
    {
        if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
            ck::IsValid(EntityScriptClass))
        {
            // Add status indicators with Unicode icons
            MainBox->AddSlot()
            .AutoHeight()
            .Padding(4.0f, 2.0f)
            [
                SNew(SBorder)
                .BorderImage(FAppStyle::GetBrush("ToolPanel.GroupBorder"))
                .BorderBackgroundColor(FLinearColor(1.0f, 1.0f, 1.0f, 1.0f))
                .Padding(6.0f, 4.0f)
                [
                    SNew(SHorizontalBox)

                    // Replication status
                    + SHorizontalBox::Slot()
                    .AutoWidth()
                    .VAlign(VAlign_Center)
                    .Padding(2.0f, 0.0f)
                    [
                        SNew(SHorizontalBox)
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("🌐") : TEXT("🏠"));
                                    }
                                }
                                return FText::FromString(TEXT("?"));
                            })
                            .Font(FCoreStyle::GetDefaultFontStyle("Bold", 12))
                            .ColorAndOpacity_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return Replication == ECk_Replication::Replicates ?
                                            FLinearColor::Green : FLinearColor(1.0f, 0.8f, 0.2f);
                                    }
                                }
                                return FLinearColor::White;
                            })
                            .ToolTipText_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("Replicated: Synchronizes across network") :
                                            TEXT("Local: Runs locally only"));
                                    }
                                }
                                return FText::GetEmpty();
                            })
                        ]
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
                        [
                            SNew(STextBlock)
                            .Text_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("Replicated") : TEXT("Local"));
                                    }
                                }
                                return FText::GetEmpty();
                            })
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 8))
                            .ColorAndOpacity(FLinearColor(0.8f, 0.8f, 0.8f))
                        ]
                    ]

                    // Instancing policy
                    + SHorizontalBox::Slot()
                    .AutoWidth()
                    .VAlign(VAlign_Center)
                    .Padding(12.0f, 2.0f, 2.0f, 2.0f)
                    [
                        SNew(SHorizontalBox)
                        .Visibility_Lambda([this]()
                        {
                            return ShouldShowInstancingIcon() ? EVisibility::Visible : EVisibility::Collapsed;
                        })
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(TEXT("◇")))
                            .Font(FCoreStyle::GetDefaultFontStyle("Bold", 12))
                            .ColorAndOpacity(FLinearColor::Blue)
                            .ToolTipText(FText::FromString(TEXT("CDO: Uses Class Default Object")))
                        ]
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(TEXT("CDO")))
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 8))
                            .ColorAndOpacity(FLinearColor(0.8f, 0.8f, 0.8f))
                        ]
                    ]
                ]
            ];
        }
    }
}

auto
    SCk_GraphNode_EntityScript::
    ShouldShowInstancingIcon() const
    -> bool
{
    if (ck::IsValid(_EntityScriptNode))
    {
        if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
            ck::IsValid(EntityScriptClass))
        {
            const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
            const auto& InstancingPolicy = EntityScriptCDO->Get_InstancingPolicy();

            return InstancingPolicy == ECk_EntityScript_InstancingPolicy::NotInstanced;
        }
    }

    return false;
}

// --------------------------------------------------------------------------------------------------------------------

#undef LOCTEXT_NAMESPACE