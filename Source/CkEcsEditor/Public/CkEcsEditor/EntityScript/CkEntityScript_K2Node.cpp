#include "CkEntityScript_K2Node.h"

#include "CkCore/EditorOnly/CkEditorOnly_Utils.h"
#include "CkCore/IO/CkIO_Utils.h"
#include "CkCore/Object/CkObject_Utils.h"
#include "CkCore/Reflection/CkReflection_Utils.h"

#include "CkEcs/EntityScript/CkEntityScript.h"
#include "CkEcs/EntityScript/CkEntityScript_Utils.h"
#include "CkEcs/Subsystem/CkEcsWorld_Subsystem.h"
#include "CkEcs/Subsystem/CkEntityScript_Subsystem.h"

#include "CkEcsEditor/CkEcsEditor_Log.h"

#include <DetailCategoryBuilder.h>
#include <DetailLayoutBuilder.h>
#include <DetailWidgetRow.h>
#include <EditorStyleSet.h>
#include <GraphEditorSettings.h>
#include <K2Node_CallFunction.h>
#include <K2Node_MakeStruct.h>
#include <K2Node_MakeStruct.h>

#include <Framework/Notifications/NotificationManager.h>

#include <Kismet/BlueprintInstancedStructLibrary.h>
#include <Kismet/GameplayStatics.h>

#include <Kismet2/BlueprintEditorUtils.h>
#include <Kismet2/KismetEditorUtilities.h>

#include <Widgets/Input/SButton.h>
#include <Widgets/Layout/SBox.h>
#include <Widgets/Notifications/SNotificationList.h>
#include <Widgets/Text/STextBlock.h>

#define LOCTEXT_NAMESPACE "UCk_K2Node_EntityScript"

// --------------------------------------------------------------------------------------------------------------------

// ReSharper disable once CppInconsistentNaming
namespace ck_k2node_entity_script
{
    static auto PinName_LifetimeOwner = TEXT("InLifetimeOwner");
    static auto PinName_Class  = TEXT("InEntityScriptClass");
    static auto PinName_LifetimeOwnerType  = TEXT("InLifetimeOwnerType");
    static auto PinName_ReturnValue  = TEXT("EntityUnderConstruction");
}

auto
    UCk_K2Node_EntityScript::
    DoCreatePinsFromEntityScript(
        UClass* InEntityScriptClass)
    -> void
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return; }

    _PinsGeneratedForEntityScript.Reset();
    _PinMetadataMap.Reset();
    AdvancedPinDisplay = ENodeAdvancedPins::Type::NoPins;

    const auto& CreatePinFromProperty = [this](const FProperty* InProperty, UObject* InContainer)
    {
        auto* Pin = CreatePin(EGPD_Input, NAME_None, InProperty->GetFName());
        _PinsGeneratedForEntityScript.Add(Pin);

        if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        Pin->PinFriendlyName = InProperty->GetDisplayNameText();

        const auto& ShowInAdvancedDisplay = InProperty->HasAllPropertyFlags(CPF_AdvancedDisplay);
        Pin->bAdvancedView = ShowInAdvancedDisplay;
        if (ShowInAdvancedDisplay && (ENodeAdvancedPins::NoPins == AdvancedPinDisplay))
        {
            AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
        }

        const auto* K2Schema = GetDefault<UEdGraphSchema_K2>();

        K2Schema->ConvertPropertyToPinType(InProperty, Pin->PinType);

        if (K2Schema->PinDefaultValueIsEditable(*Pin))
        {
            auto DefaultValueAsString = FString{};
            const auto& DefaultValueSet = FBlueprintEditorUtils::PropertyValueToString(InProperty, reinterpret_cast<const uint8*>(InContainer), DefaultValueAsString, this);
            check(DefaultValueSet);

            K2Schema->SetPinAutogeneratedDefaultValue(Pin, DefaultValueAsString);
        }
        else if (const auto* StructProperty = CastField<FStructProperty>(InProperty);
                 ck::IsValid(StructProperty))
        {
            if (const auto* StructData = InProperty->ContainerPtrToValuePtr<uint8>(InContainer))
            {
                FString DefaultStructValue;
                StructProperty->Struct->ExportText(
                    DefaultStructValue,
                    StructData,
                    StructData,
                    InContainer,
                    PPF_None,
                    nullptr);

                K2Schema->TrySetDefaultValue(*Pin, DefaultStructValue);
            }
        }

        K2Schema->ConstructBasicPinTooltip(*Pin, InProperty->GetToolTipText(), Pin->PinToolTip);

        if (const auto* MetaDataMap = InProperty->GetMetaDataMap())
        {
            for (const auto& MetaDataKvp : *MetaDataMap)
            {
                _PinMetadataMap.FindOrAdd(Pin->PinName).Add(MetaDataKvp.Key, MetaDataKvp.Value);
            }
        }
    };

    auto* ConstructionScriptCDO = InEntityScriptClass->GetDefaultObject();

    for (const auto* ExposedProperty : UCk_Utils_Reflection_UE::Get_ExposedPropertiesOfClass(InEntityScriptClass))
    {
        CreatePinFromProperty(ExposedProperty, ConstructionScriptCDO);
    }
}

auto
    UCk_K2Node_EntityScript::
    DoOnClassPinChanged()
    -> void
{
    TArray<UEdGraphPin*> OldPins = Pins;
    TArray<UEdGraphPin*> OldClassPins;

    for (auto* OldPin : OldPins)
    {
        if (NOT _PinsGeneratedForEntityScript.Contains(OldPin))
        { continue; }

        Pins.Remove(OldPin);
        OldClassPins.Add(OldPin);
    }

    TArray<UEdGraphPin*> NewClassPins;

    if (auto* ClassToSpawn = DoGet_EntityScriptClass(Pins);
        ck::IsValid(ClassToSpawn))
    {
        DoCreatePinsFromEntityScript(ClassToSpawn);
    }

    RestoreSplitPins(OldPins);
    RewireOldPinsToNewPins(OldClassPins, Pins, nullptr);
    GetGraph()->NotifyGraphChanged();
    FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}

auto
    UCk_K2Node_EntityScript::
    IsNodePure() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    ReallocatePinsDuringReconstruction(
        TArray<UEdGraphPin*>& InOldPins)
    -> void
{
    for (const auto Pin : InOldPins)
    {
        if (Pin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
        {
            const auto EnumValue = UCk_Utils_Enum_UE::Get_EnumFromString<ECk_EntityLifetime_OwnerType>(Pin->DefaultValue);
            CK_ENSURE_IF_NOT(ck::IsValid(EnumValue),
                TEXT("Failed to get Enum value from string [{}]. This should have worked. Some EntityScript Spawn nodes in the graph [{}] might be faulty."),
                Pin->DefaultValue, this->GetGraph())
            { break; }

            _LifetimeOwnerType = *EnumValue;
            break;
        }
    }

    // Now proceed with standard pin reallocation
    AllocateDefaultPins();

    // Get entity script class from old pins
    if (auto* EntityScriptClass = DoGet_EntityScriptClass(InOldPins))
    {
        DoCreatePinsFromEntityScript(EntityScriptClass);
    }

    RestoreSplitPins(InOldPins);
}

auto
    UCk_K2Node_EntityScript::
    ShouldShowNodeProperties() const
    -> bool
{
    return true;
}

auto
    UCk_K2Node_EntityScript::
    GetNodeTitle(
        ENodeTitleType::Type InTitleType) const
    -> FText
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass();
        ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =  UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();
        const auto& InstancingPolicy = EntityScriptCDO->Get_InstancingPolicy();

        return CK_UTILS_IO_GET_LOCTEXT
        (
            TEXT("UCk_K2Node_EntityScript"),
            *ck::Format_UE(TEXT("[Ck] Spawn {}\n{} - {}"),
                EntityScriptClass->GetDisplayNameText(),
                Replication == ECk_Replication::Replicates ? TEXT("Replicated" : TEXT("Local")),
                InstancingPolicy == ECk_EntityScript_InstancingPolicy::NotInstanced ? TEXT("CDO" : TEXT("Instanced")))
        );
    }

    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Request Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    GetIconAndTint(
        FLinearColor& OutColor) const
    -> FSlateIcon
{
    OutColor = GetDefault<UGraphEditorSettings>()->FunctionCallNodeTitleColor;
    return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Kismet.AllClasses.FunctionIcon"));
}

auto
    UCk_K2Node_EntityScript::
    GetReplicationIcon() const
    -> FSlateIcon
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass(); ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =
            UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();

        if (Replication == ECk_Replication::Replicates)
        {
            // Use network/multiplayer icon
            return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Icons.Network"));
        }
        else
        {
            // Use local/single player icon
            return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Icons.Computer"));
        }
    }

    return FSlateIcon();
}

auto
    UCk_K2Node_EntityScript::
    GetCornerIcon() const
    -> FName
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass();
        ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =  UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();

        if (Replication == ECk_Replication::Replicates)
        {
            return TEXT("Graph.Replication.AuthorityOnly");
        }
    }

    return Super::GetCornerIcon();
}

auto
    UCk_K2Node_EntityScript::
    GetMenuCategory() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("Ck|EntityScript")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoAllocate_DefaultPins()
    -> void
{
    using namespace ck_k2node_entity_script;

    CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Class,
        UCk_EntityScript_UE::StaticClass(),
        PinName_Class
    );

    auto* LifetimeOwnerTypeEnumPin =  CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Byte,
        StaticEnum<ECk_EntityLifetime_OwnerType>(),
        PinName_LifetimeOwnerType
    );
    LifetimeOwnerTypeEnumPin->DefaultValue = ck::Format_UE(TEXT("{}"), _LifetimeOwnerType);

    auto* ReturnValuePin = CreatePin
    (
        EGPD_Output,
        UEdGraphSchema_K2::PC_Struct,
        FCk_Handle_PendingEntityScript::StaticStruct(),
        PinName_ReturnValue
    );
    ReturnValuePin->PinToolTip = TEXT("The handle to the newly spawned Entity (not yet constructed)");

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseCustomEntity)
    {
        CreatePin(
            EGPD_Input,
            UEdGraphSchema_K2::PC_Struct,
            FCk_Handle::StaticStruct(),
            PinName_LifetimeOwner
        );
    }

    DoCreatePinsFromEntityScript(DoGet_EntityScriptClass());
}

auto
    UCk_K2Node_EntityScript::
    IsCompatibleWithGraph(
        UEdGraph const* InGraph) const
    -> bool
{
    return Super::IsCompatibleWithGraph(InGraph);
}

auto
    UCk_K2Node_EntityScript::
    PinConnectionListChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::PinConnectionListChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        DoOnClassPinChanged();
    }
}

auto
    UCk_K2Node_EntityScript::
    GetPinMetaData(
        FName InPinName,
        FName InKey)
    -> FString
{
    if (InPinName == ck_k2node_entity_script::PinName_Class && InKey == FBlueprintMetadata::MD_AllowAbstractClasses)
    { return TEXT("False"); }

    if (const TMap<FName, FString>* Metadata = _PinMetadataMap.Find(InPinName))
    {
        if (const FString* Value = Metadata->Find(InKey))
        {
            return *Value;
        }
    }

    return Super::GetPinMetaData(InPinName, InKey);
}

auto
    UCk_K2Node_EntityScript::
    GetJumpTargetForDoubleClick() const
    -> UObject*
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    { return Super::GetJumpTargetForDoubleClick(); }

    return UCk_Utils_Object_UE::Get_ClassGeneratedByBlueprint(EntityScriptClass);
}

auto
    UCk_K2Node_EntityScript::
    CreateVisualWidget()
    -> TSharedPtr<SGraphNode>
{
    return SNew(SCk_GraphNode_EntityScript, this);
}

auto
    UCk_K2Node_EntityScript::
    OnInterfacePinButtonClicked(FName PinName) const
    -> void
{
    auto* ClickedPin = FindPin(PinName);
    if (ck::Is_NOT_Valid(ClickedPin, ck::IsValid_Policy_NullptrOnly{}) || NOT IsInterfacePin(ClickedPin))
    { return; }

    if (ClickedPin->Direction != EGPD_Input)
    { return; }

    UClass* InterfaceClass = nullptr;
    if (ClickedPin->PinType.PinSubCategoryObject.IsValid())
    {
        InterfaceClass = Cast<UClass>(ClickedPin->PinType.PinSubCategoryObject.Get());
    }

    if (ck::Is_NOT_Valid(InterfaceClass) || NOT InterfaceClass->HasAnyClassFlags(CLASS_Interface))
    {
        auto NotificationInfo = FNotificationInfo(FText::FromString(TEXT("Invalid interface class for pin")));
        NotificationInfo.ExpireDuration = 3.0f;
        NotificationInfo.bFireAndForget = true;
        FSlateNotificationManager::Get().AddNotification(NotificationInfo);
        return;
    }

    auto* Blueprint = GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    {
        FNotificationInfo NotificationInfo(FText::FromString(TEXT("Could not find blueprint to implement interface")));
        NotificationInfo.ExpireDuration = 3.0f;
        NotificationInfo.bFireAndForget = true;
        FSlateNotificationManager::Get().AddNotification(NotificationInfo);
        return;
    }

    if (const auto& Success = UCk_Utils_EditorOnly_UE::Request_ImplementNewInterface(Blueprint, InterfaceClass);
        Success == ECk_SucceededFailed::Failed)
    { return; }

    auto NotificationInfo = FNotificationInfo(FText::FromString(ck::Format_UE(TEXT("Implemented interface: {}"), InterfaceClass->GetName())));
    NotificationInfo.ExpireDuration = 3.0f;
    NotificationInfo.bFireAndForget = true;
    FSlateNotificationManager::Get().AddNotification(NotificationInfo);

    FBlueprintEditorUtils::MarkBlueprintAsModified(Blueprint);
}

auto
    UCk_K2Node_EntityScript::
    IsInterfacePin(
        UEdGraphPin* Pin)
    -> bool
{
    if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
    { return false; }

    if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Interface)
    { return true; }

    if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Class &&
        Pin->PinType.PinSubCategoryObject.IsValid())
    {
        if (const auto* Class = Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get());
            ck::IsValid(Class))
        {
            return Class->HasAnyClassFlags(CLASS_Interface);
        }
    }

    return false;
}

auto
    UCk_K2Node_EntityScript::
    IsPinGeneratedFromEntityScript(UEdGraphPin* Pin) const
    -> bool
{
    return _PinsGeneratedForEntityScript.Contains(Pin);
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntitySpawnParamsStruct(
        UClass* InEntityScriptClass,
        FKismetCompilerContext& InCompilerContext)
        -> UScriptStruct*
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return {}; }

    auto* EntityScriptSubsystem = GEngine->GetEngineSubsystem<UCk_EntityScript_Subsystem_UE>();
    if (ck::Is_NOT_Valid(EntityScriptSubsystem))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to get Entity Script Subsystem"));
        return {};
    }

    auto* SpawnParamsStruct = EntityScriptSubsystem->GetOrCreate_SpawnParamsStructForEntity(InEntityScriptClass);
    if (ck::Is_NOT_Valid(SpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to find valid Spawn Params struct for Entity Script [{}]"), InEntityScriptClass);
        return {};
    }

    return SpawnParamsStruct;
}

auto
    UCk_K2Node_EntityScript::
    DoExpandNode(
        FKismetCompilerContext& InCompilerContext,
        UEdGraph* InSourceGraph,
        ECk_ValidInvalid InNodeValidity)
    -> void
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script", "Invalid Entity Script. @@").ToString(), this);
        return;
    }

    if (EntityScriptClass == UCk_EntityScript_UE::StaticClass())
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Trying to Spawn Base Entity Script", "Cannot Spawn Base Entity Script. @@").ToString(), this);
        return;
    }

    _LifetimeOwnerType = DoGet_LifetimeOwnerType();

    auto* EntitySpawnParamsStruct = DoGet_EntitySpawnParamsStruct(EntityScriptClass, InCompilerContext);

    if (ck::Is_NOT_Valid(EntitySpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script Spawn Params struct", "Invalid Entity Script Spawn Params struct @@").ToString(), this);
        return;
    }

    // Create a Make Struct node for the Spawn Params
    auto* MakeSpawnParamsStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_MakeStruct>(this, InSourceGraph);
    MakeSpawnParamsStruct_Node->StructType = EntitySpawnParamsStruct;
    MakeSpawnParamsStruct_Node->bMadeAfterOverridePinRemoval = true;
    MakeSpawnParamsStruct_Node->AllocateDefaultPins();

    // Create a MakeInstancedStruct node to convert UScriptStruct to FInstancedStruct
    auto* MakeInstancedStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    MakeInstancedStruct_Node->SetFromFunction(UBlueprintInstancedStructLibrary::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UBlueprintInstancedStructLibrary, MakeInstancedStruct)));
    MakeInstancedStruct_Node->AllocateDefaultPins();

    const auto& TryCopyValueOrLinkPin = [&](UEdGraphPin* InPinToCopyOrLinkFrom)
    {
        auto* FoundMakeStructPin = MakeSpawnParamsStruct_Node->FindPinByPredicate([&](const UEdGraphPin* InPin)
        {
            return InPin->PinFriendlyName.ToString() == InPinToCopyOrLinkFrom->PinName.ToString();
        });

        if (ck::Is_NOT_Valid(FoundMakeStructPin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        if (NOT InPinToCopyOrLinkFrom->DefaultValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultValue = InPinToCopyOrLinkFrom->DefaultValue;
        }

        if (ck::IsValid(InPinToCopyOrLinkFrom->DefaultObject))
        {
            FoundMakeStructPin->DefaultObject = InPinToCopyOrLinkFrom->DefaultObject;
        }

        if (NOT InPinToCopyOrLinkFrom->DefaultTextValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultTextValue = InPinToCopyOrLinkFrom->DefaultTextValue;
        }

        if (NOT InPinToCopyOrLinkFrom->LinkedTo.IsEmpty())
        {
            for (auto* LinkedPin : InPinToCopyOrLinkFrom->LinkedTo)
            {
                InCompilerContext.GetSchema()->TryCreateConnection(LinkedPin, FoundMakeStructPin);
            }
        }
    };

    for (auto* Pin : this->Pins)
    {
        if (Pin->Direction == EGPD_Input &&
            Pin != this->GetExecPin() &&
            Pin->PinName != ck_k2node_entity_script::PinName_Class &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwnerType &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwner)
        {
            TryCopyValueOrLinkPin(Pin);
        }
    }

    // Set up 'Request_SpawnEntity' function node
    auto* SpawnEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    SpawnEntity_Node->FunctionReference.SetExternalMember
    (
        GET_FUNCTION_NAME_CHECKED(UCk_Utils_EntityScript_UE, Request_SpawnEntity),
        UCk_Utils_EntityScript_UE::StaticClass()
    );
    SpawnEntity_Node->AllocateDefaultPins();
    InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(SpawnEntity_Node, this);

    // Connect everything together
    if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(EntitySpawnParamsStruct->GetFName(), ECk_EditorGraph_PinDirection::Output, *MakeSpawnParamsStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("Value"), ECk_EditorGraph_PinDirection::Input, *MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*SpawnEntity_Node),
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InSpawnParams"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            },
        }
    ) == ECk_SucceededFailed::Failed) { return; }

    // Link or assign entity script class
    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InEntityScriptClass"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed)
    {
        if (auto* EntityScriptClassPin = SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_Class);
            ck::IsValid(EntityScriptClassPin, ck::IsValid_Policy_NullptrOnly{}))
        {
            InCompilerContext.GetSchema()->TrySetDefaultValue(*EntityScriptClassPin, EntityScriptClass->GetClassPathName().ToString());
            UCk_Utils_EditorGraph_UE::Request_ForceRefreshNode(*SpawnEntity_Node);
        }
    }

    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*SpawnEntity_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_ReturnValue, ECk_EditorGraph_PinDirection::Output, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed) { return; }

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseTransientEntity)
    {
        // Set up 'Get_TransientEntity' function node
        auto* GetTransientEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
        GetTransientEntity_Node->FunctionReference.SetExternalMember
        (
            GET_FUNCTION_NAME_CHECKED(UCk_Utils_EcsWorld_Subsystem_UE, Get_TransientEntity_FromContextObject),
            UCk_Utils_EcsWorld_Subsystem_UE::StaticClass()
        );
        GetTransientEntity_Node->AllocateDefaultPins();
        InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(GetTransientEntity_Node, this);

        if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin_Result(*GetTransientEntity_Node),
                    UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InLifetimeOwner"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
                },
            }
        ) == ECk_SucceededFailed::Failed) { return; }
    }
    else
    {
        if (UCk_Utils_EditorGraph_UE::Request_LinkPins
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_LifetimeOwner, ECk_EditorGraph_PinDirection::Input, *this),
                    SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_LifetimeOwner, EGPD_Input)
                },
            },
            ECk_EditorGraph_PinLinkType::Move
        ) == ECk_SucceededFailed::Failed) { return; }
    }

    BreakAllNodeLinks();
}

auto
    UCk_K2Node_EntityScript::
    DoGet_Menu_NodeTitle() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoPinDefaultValueChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::DoPinDefaultValueChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
    {
        if (const auto NewLifetimeOwnerType = DoGet_LifetimeOwnerType();
            _LifetimeOwnerType != NewLifetimeOwnerType)
        {
            _LifetimeOwnerType = NewLifetimeOwnerType;
            ReconstructNode();
        }
        return;
    }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        auto* EntityScriptClass = Cast<UClass>(InPin->DefaultObject);

        const auto& CheckPinValidity = [&]() -> ECk_SucceededFailed
        {
            if (ck::Is_NOT_Valid(EntityScriptClass))
            { return ECk_SucceededFailed::Failed; }

            CK_ENSURE_IF_NOT(NOT EntityScriptClass->HasAnyClassFlags(_DisallowedFlags), TEXT("The DefaultObject in the [{}] pin cannot be an Abstract/Deprecated/None class."), InPin->PinName)
            { return ECk_SucceededFailed::Failed; }

            return ECk_SucceededFailed::Succeeded;
        };

        if (CheckPinValidity() == ECk_SucceededFailed::Failed)
        {
            InPin->DefaultObject = nullptr;
        }

        DoOnClassPinChanged();
        return;
    }
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntityScriptClass(
        TOptional<TArray<UEdGraphPin*>> InPinsToSearch) const
    -> UClass*
{
    if (ck::Is_NOT_Valid(InPinsToSearch))
    {
        InPinsToSearch = Pins;
    }

    const auto& ClassPin = UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *InPinsToSearch);

    if (ck::Is_NOT_Valid(ClassPin))
    { return {}; }

    const auto& ClassPinCDO = (*ClassPin)->DefaultObject;
    const auto& ClassPinLinkedTo = (*ClassPin)->LinkedTo;

    if (ClassPinLinkedTo.Num() == 0)
    {
        return ck::IsValid(ClassPinCDO) ? CastChecked<UClass>(ClassPinCDO) : nullptr;
    }

    const auto& ClassSource = ClassPinLinkedTo[0];
    return  ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
}

auto
    UCk_K2Node_EntityScript::
    DoGet_LifetimeOwnerType() const
    -> ECk_EntityLifetime_OwnerType
{
    return *UCk_Utils_EditorGraph_UE::Get_Pin_EnumValue<ECk_EntityLifetime_OwnerType>(
        ck_k2node_entity_script::PinName_LifetimeOwnerType, ECk_EditorGraph_PinDirection::Input, *this);
}

auto
    UCk_K2Node_EntityScript::
    GetImplementedInterfaces() const
    -> TArray<UClass*>
{
    auto ConnectedInterfaces = TArray<UClass*>{};

    // Get all interfaces implemented in this blueprint first
    auto AllBlueprintInterfaces = TArray<UClass*>{};
    if (auto* Blueprint = GetBlueprint();
        ck::IsValid(Blueprint))
    {
        for (const auto& InterfaceDesc : Blueprint->ImplementedInterfaces)
        {
            if (auto* InterfaceClass = InterfaceDesc.Interface.Get();
                ck::IsValid(InterfaceClass, ck::IsValid_Policy_NullptrOnly{}))
            {
                AllBlueprintInterfaces.Add(InterfaceClass);
            }
        }
    }

    if (AllBlueprintInterfaces.Num() == 0)
    {
        return ConnectedInterfaces;
    }

    // Simple approach: For each interface pin that has a non-default value,
    // check if that interface is implemented in the blueprint
    for (auto* Pin : Pins)
    {
        if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}) ||
            Pin->Direction != EGPD_Input ||
            NOT IsPinGeneratedFromEntityScript(Pin) ||
            NOT IsInterfacePin(Pin))
        { continue; }

        // Method 1: Check DefaultObject for interface class
        if (ck::IsValid(Pin->DefaultObject))
        {
            if (auto* InterfaceClass = Cast<UClass>(Pin->DefaultObject);
                ck::IsValid(InterfaceClass) &&
                InterfaceClass->HasAnyClassFlags(CLASS_Interface) &&
                AllBlueprintInterfaces.Contains(InterfaceClass))
            {
                ConnectedInterfaces.AddUnique(InterfaceClass);
                continue;
            }
        }

        // Method 2: Check PinSubCategoryObject
        if (Pin->PinType.PinSubCategoryObject.IsValid())
        {
            if (auto* InterfaceClass = Cast<UClass>(Pin->PinType.PinSubCategoryObject.Get());
                ck::IsValid(InterfaceClass) &&
                InterfaceClass->HasAnyClassFlags(CLASS_Interface) &&
                AllBlueprintInterfaces.Contains(InterfaceClass))
            {
                ConnectedInterfaces.AddUnique(InterfaceClass);
                continue;
            }
        }

        // Method 3: Check connections
        if (Pin->LinkedTo.Num() > 0)
        {
            for (auto* LinkedPin : Pin->LinkedTo)
            {
                if (ck::Is_NOT_Valid(LinkedPin, ck::IsValid_Policy_NullptrOnly{}))
                { continue; }

                if (LinkedPin->PinType.PinSubCategoryObject.IsValid())
                {
                    if (auto* InterfaceClass = Cast<UClass>(LinkedPin->PinType.PinSubCategoryObject.Get());
                        ck::IsValid(InterfaceClass) &&
                        InterfaceClass->HasAnyClassFlags(CLASS_Interface) &&
                        AllBlueprintInterfaces.Contains(InterfaceClass))
                    {
                        ConnectedInterfaces.AddUnique(InterfaceClass);
                        break;
                    }
                }
            }
        }
    }

    return ConnectedInterfaces;
}

auto
    UCk_K2Node_EntityScript::
    GetInterfaceFunctions(
        UClass* InterfaceClass) const
    -> TArray<UFunction*>
{
    TArray<UFunction*> InterfaceFunctions;

    if (ck::Is_NOT_Valid(InterfaceClass))
    { return InterfaceFunctions; }

    // Get all functions from the interface
    for (TFieldIterator<UFunction> FunctionIt(InterfaceClass, EFieldIteratorFlags::IncludeSuper);
         FunctionIt; ++FunctionIt)
    {
        auto* Function = *FunctionIt;

        if (ck::Is_NOT_Valid(Function))
        { continue; }

        const FString FunctionName = Function->GetName();

        // Filter out ExecuteUbergraph - this is an internal Blueprint function, not a real interface function
        if (FunctionName.Contains(TEXT("ExecuteUbergraph"), ESearchCase::IgnoreCase))
        {
            ck::ecs_editor::Warning(TEXT("Filtering out ExecuteUbergraph function: [{}]"), FunctionName);
            continue;
        }

        // Filter out other internal/generated functions
        if (FunctionName.StartsWith(TEXT("__")) ||
            Function->HasAnyFunctionFlags(FUNC_Native) ||
            Function->HasAnyFunctionFlags(FUNC_Delegate))
        {
            continue;
        }

        // Only include blueprint callable/implementable functions
        if (Function->HasAnyFunctionFlags(FUNC_BlueprintCallable | FUNC_BlueprintEvent))
        {
            InterfaceFunctions.Add(Function);
        }
    }

    return InterfaceFunctions;
}

auto
    UCk_K2Node_EntityScript::
    NavigateToInterfaceFunction(
        UFunction* Function) const
    -> void
{
    if (ck::Is_NOT_Valid(Function))
    { return; }

    auto* Blueprint = GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    { return; }

    // Try to find existing implementation
    UEdGraph* FunctionGraph = nullptr;

    // Look for existing function graph
    for (const auto& Graph : Blueprint->FunctionGraphs)
    {
        if (ck::Is_NOT_Valid(Graph))
        { continue; }

        if (Graph->GetFName() == Function->GetFName())
        {
            FunctionGraph = Graph;
            break;
        }
    }

    // If no graph exists, try to find an event node
    if (ck::Is_NOT_Valid(FunctionGraph))
    {
        for (const auto& Graph : Blueprint->UbergraphPages)
        {
            if (ck::Is_NOT_Valid(Graph))
            { continue; }

            for (const auto& Node : Graph->Nodes)
            {
                if (auto* EventNode = Cast<UK2Node_Event>(Node);
                    ck::IsValid(EventNode))
                {
                    if (EventNode->EventReference.GetMemberName() == Function->GetFName())
                    {
                        FunctionGraph = Graph;

                        // Focus on the specific event node
                        FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(EventNode);
                        return;
                    }
                }
            }
        }
    }

    if (ck::IsValid(FunctionGraph))
    {
        // Open the function graph
        FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(FunctionGraph);
    }
    else
    {
        // Show notification that function is not implemented
        auto NotificationInfo = FNotificationInfo(
            FText::FromString(ck::Format_UE(TEXT("Interface function '{}' is not yet implemented"),
                                          Function->GetName())));
        NotificationInfo.ExpireDuration = 3.0f;
        NotificationInfo.bFireAndForget = true;
        FSlateNotificationManager::Get().AddNotification(NotificationInfo);
    }
}

auto
    UCk_K2Node_EntityScript::
    IsFunctionImplemented(
        UFunction* Function) const
-> bool
{
    if (ck::Is_NOT_Valid(Function))
    { return false; }

    auto* Blueprint = GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    { return false; }

    // Check for function graphs (functions)
    for (const auto& Graph : Blueprint->FunctionGraphs)
    {
        if (ck::IsValid(Graph) && Graph->GetFName() == Function->GetFName())
        {
            return true;
        }
    }

    // Check for event nodes (events)
    for (const auto& Graph : Blueprint->UbergraphPages)
    {
        if (ck::Is_NOT_Valid(Graph))
        { continue; }

        for (const auto& Node : Graph->Nodes)
        {
            if (auto* EventNode = Cast<UK2Node_Event>(Node);
                ck::IsValid(EventNode))
            {
                if (EventNode->EventReference.GetMemberName() == Function->GetFName())
                {
                    return true;
                }
            }
        }
    }

    return false;
}

auto
    UCk_K2Node_EntityScript::
    ImplementInterfaceFunction(
        UFunction* Function) const
    -> bool
{
    if (ck::Is_NOT_Valid(Function))
    { return false; }

    auto* Blueprint = GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    { return false; }

    const FString FunctionName = Function->GetName();

    if (Function->HasAnyFunctionFlags(FUNC_BlueprintEvent))
    {
        // For events, add an event node to the event graph
        return ImplementInterfaceEvent(Function, Blueprint);
    }
    else
    {
        // For functions, create a new function graph
        return ImplementInterfaceFunction_Graph(Function, Blueprint);
    }
}

auto
    UCk_K2Node_EntityScript::
    ImplementInterfaceEvent(
        UFunction* Function,
        UBlueprint* Blueprint)
    -> bool
{
    if (ck::Is_NOT_Valid(Function) || ck::Is_NOT_Valid(Blueprint))
    { return false; }

    // Find or create the main event graph
    UEdGraph* EventGraph = nullptr;
    if (Blueprint->UbergraphPages.Num() > 0)
    {
        EventGraph = Blueprint->UbergraphPages[0];
    }
    else
    {
        // Create a new event graph if none exists
        EventGraph = FBlueprintEditorUtils::CreateNewGraph(
            Blueprint,
            FBlueprintEditorUtils::FindUniqueKismetName(Blueprint, TEXT("EventGraph")),
            UEdGraph::StaticClass(),
            UEdGraphSchema_K2::StaticClass()
        );

        if (ck::IsValid(EventGraph))
        {
            Blueprint->UbergraphPages.Add(EventGraph);
        }
    }

    if (ck::Is_NOT_Valid(EventGraph))
    { return false; }

    auto* EventNode = NewObject<UK2Node_Event>(EventGraph);
    if (ck::Is_NOT_Valid(EventNode))
    { return false; }

    EventNode->EventReference.SetExternalMember(Function->GetFName(), Function->GetOwnerClass());
    EventNode->bOverrideFunction = true;

    EventGraph->AddNode(EventNode, true);

    EventNode->AllocateDefaultPins();

    const auto& NewNodePosition = EventGraph->GetGoodPlaceForNewNode();

    EventNode->NodePosX = NewNodePosition.X;
    EventNode->NodePosY = NewNodePosition.Y;

    EventNode->ReconstructNode();

    FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(Blueprint);

    return true;
}

auto
    UCk_K2Node_EntityScript::
    ImplementInterfaceFunction_Graph(
        UFunction* Function,
        UBlueprint* Blueprint)
        -> bool
{
    if (ck::Is_NOT_Valid(Function) || ck::Is_NOT_Valid(Blueprint))
    { return false; }

    const FString FunctionName = Function->GetName();

    // Create a new function graph
    auto* FunctionGraph = FBlueprintEditorUtils::CreateNewGraph(
        Blueprint,
        *FunctionName,
        UEdGraph::StaticClass(),
        UEdGraphSchema_K2::StaticClass()
    );

    if (ck::Is_NOT_Valid(FunctionGraph))
    { return false; }

    Blueprint->FunctionGraphs.Add(FunctionGraph);

    FBlueprintEditorUtils::AddFunctionGraph(Blueprint, FunctionGraph, true, Function->GetOwnerClass());

    FBlueprintEditorUtils::MarkBlueprintAsStructurallyModified(Blueprint);

    return true;
}

// --------------------------------------------------------------------------------------------------------------------

auto
    SCk_GraphPin_Interface::
    Construct(
        const FArguments& InArgs,
        UEdGraphPin* InPin)
    -> void
{
    SGraphPin::Construct(SGraphPin::FArguments(), InPin);
}

auto
    SCk_GraphPin_Interface::
    GetDefaultValueWidget()
    -> TSharedRef<SWidget>
{
    const auto& IsAlreadyImplemented = IsInterfaceAlreadyImplemented();

    // Instead of using the original widget, let's create our own integrated version
    return SNew(SHorizontalBox)
        + SHorizontalBox::Slot()
        .FillWidth(1.0f)
        .VAlign(VAlign_Center)
        [
            // Create a simple text block for the pin value instead of using the original widget
            SNew(STextBlock)
            .Text_Lambda([this]()
            {
                if (GraphPinObj && GraphPinObj->PinType.PinSubCategoryObject.IsValid())
                {
                    if (const auto* InterfaceClass = Cast<UClass>(GraphPinObj->PinType.PinSubCategoryObject.Get()))
                    {
                        return FText::FromString(InterfaceClass->GetName());
                    }
                }
                return FText::FromString(TEXT("None"));
            })
            .ColorAndOpacity(FLinearColor{0.1f, 0.1f, 0.1f, 1.0f})
            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 9))
        ]
        + SHorizontalBox::Slot()
        .AutoWidth()
        .VAlign(VAlign_Center)
        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
        [
            SNew(SBox)
            .WidthOverride(18.0f)
            .HeightOverride(18.0f)
            [
                SNew(SButton)
                .ButtonStyle(FAppStyle::Get(), "HoverHintOnly")
                .ForegroundColor(FSlateColor::UseForeground())
                .OnClicked(this, &SCk_GraphPin_Interface::OnImplementInterfaceClicked)
                .IsEnabled(NOT IsAlreadyImplemented)
                .ToolTipText(IsAlreadyImplemented ?
                    FText::FromString(TEXT("Interface already implemented in the current blueprint")) :
                    FText::FromString(TEXT("Implement this interface in the current blueprint")))
                .Content()
                [
                    SNew(STextBlock)
                    .Text(FText::FromString(IsAlreadyImplemented ? TEXT("●") : TEXT("+")))
                    .Font(FCoreStyle::GetDefaultFontStyle("Bold", 10))
                    .Justification(ETextJustify::Center)
                    .ColorAndOpacity(IsAlreadyImplemented ? FColor::Cyan : FColor::Green)
                ]
            ]
        ];
}

auto
    SCk_GraphPin_Interface::
    OnImplementInterfaceClicked() const
    -> FReply
{
    if (const auto& EntityScriptNode = Get_EntityScriptNode();
        ck::IsValid(EntityScriptNode))
    {
        EntityScriptNode->OnInterfacePinButtonClicked(GraphPinObj->PinName);
    }

    return FReply::Handled();
}

auto
    SCk_GraphPin_Interface::
    Get_InterfaceClass() const
    -> UClass*
{
    if (ck::Is_NOT_Valid(GraphPinObj, ck::IsValid_Policy_NullptrOnly{}) || ck::Is_NOT_Valid(GraphPinObj->PinType.PinSubCategoryObject))
    { return {}; }

    return Cast<UClass>(GraphPinObj->PinType.PinSubCategoryObject.Get());
}

auto
    SCk_GraphPin_Interface::
    IsInterfaceAlreadyImplemented() const
    -> bool
{
    auto* InterfaceClass = Get_InterfaceClass();
    if (ck::Is_NOT_Valid(GraphPinObj, ck::IsValid_Policy_NullptrOnly{}) || NOT InterfaceClass->HasAnyClassFlags(CLASS_Interface))
    { return {}; }

    const auto* EntityScriptNode = Get_EntityScriptNode();
    if (ck::Is_NOT_Valid(EntityScriptNode))
    { return {}; }

    const auto* Blueprint = EntityScriptNode->GetBlueprint();
    if (ck::Is_NOT_Valid(Blueprint))
    { return {}; }

    return UCk_Utils_EditorOnly_UE::Get_DoesBlueprintImplementInterface(Blueprint, InterfaceClass);
}

auto
    SCk_GraphPin_Interface::
    Get_EntityScriptNode() const
    -> UCk_K2Node_EntityScript*
{
    if (GraphPinObj && GraphPinObj->GetOuter())
    {
        return Cast<UCk_K2Node_EntityScript>(GraphPinObj->GetOuter());
    }
    return nullptr;
}

// --------------------------------------------------------------------------------------------------------------------

auto
    SCk_GraphNode_EntityScript::
    Construct(
        const FArguments& InArgs,
        UCk_K2Node_EntityScript* InNode)
    -> void
{
    GraphNode = InNode;
    _EntityScriptNode = CastChecked<UCk_K2Node_EntityScript>(InNode);

    UpdateGraphNode();
}

auto
    SCk_GraphNode_EntityScript::
    CreatePinWidgets()
    -> void
{
    for (auto PinIt = GraphNode->Pins.CreateConstIterator(); PinIt; ++PinIt)
    {
        auto* CurrentPin = *PinIt;

        if (CurrentPin->bHidden)
        { continue; }

        if (auto NewPin = ShouldPinHaveInterfaceButton(CurrentPin) ? SNew(SCk_GraphPin_Interface, CurrentPin) : CreatePinWidget(CurrentPin);
            NewPin.IsValid())
        {
            this->AddPin(NewPin.ToSharedRef());
        }
    }
}

auto
    SCk_GraphNode_EntityScript::
    ShouldPinHaveInterfaceButton(
        UEdGraphPin* Pin) const
    -> bool
{
    if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}) || Pin->Direction != EGPD_Input || ck::Is_NOT_Valid(_EntityScriptNode))
    { return {}; }

    // Only add buttons to pins that are:
    // 1. Generated from EntityScript
    // 2. Are interface type pins
    return _EntityScriptNode->IsPinGeneratedFromEntityScript(Pin) &&
           _EntityScriptNode->IsInterfacePin(Pin);
}

auto
    SCk_GraphNode_EntityScript::
    CreateBelowPinControls(
        TSharedPtr<SVerticalBox> MainBox)
    -> void
{
    SGraphNode::CreateBelowPinControls(MainBox);

    if (ck::IsValid(_EntityScriptNode))
    {
        if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
            ck::IsValid(EntityScriptClass))
        {
            // Add status indicators with Unicode icons
            MainBox->AddSlot()
            .AutoHeight()
            .Padding(4.0f, 2.0f)
            [
                SNew(SBorder)
                .BorderImage(FAppStyle::GetBrush("ToolPanel.GroupBorder"))
                .BorderBackgroundColor(FLinearColor(1.0f, 1.0f, 1.0f, 1.0f))
                .Padding(6.0f, 4.0f)
                [
                    SNew(SHorizontalBox)

                    // Replication status
                    + SHorizontalBox::Slot()
                    .AutoWidth()
                    .VAlign(VAlign_Center)
                    .Padding(2.0f, 0.0f)
                    [
                        SNew(SHorizontalBox)
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("🌐") : TEXT("🏠"));
                                    }
                                }
                                return FText::FromString(TEXT("?"));
                            })
                            .Font(FCoreStyle::GetDefaultFontStyle("Bold", 12))
                            .ColorAndOpacity_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return Replication == ECk_Replication::Replicates ?
                                            FLinearColor::Green : FLinearColor(1.0f, 0.8f, 0.2f);
                                    }
                                }
                                return FLinearColor::White;
                            })
                            .ToolTipText_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("Replicated: Synchronizes across network") :
                                            TEXT("Local: Runs locally only"));
                                    }
                                }
                                return FText::GetEmpty();
                            })
                        ]
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
                        [
                            SNew(STextBlock)
                            .Text_Lambda([this]()
                            {
                                if (ck::IsValid(_EntityScriptNode))
                                {
                                    if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
                                        ck::IsValid(EntityScriptClass))
                                    {
                                        const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
                                        const auto& Replication = EntityScriptCDO->Get_Replication();

                                        return FText::FromString(Replication == ECk_Replication::Replicates ?
                                            TEXT("Replicated") : TEXT("Local"));
                                    }
                                }
                                return FText::GetEmpty();
                            })
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 8))
                            .ColorAndOpacity(FLinearColor(0.8f, 0.8f, 0.8f))
                        ]
                    ]

                    // Instancing policy
                    + SHorizontalBox::Slot()
                    .AutoWidth()
                    .VAlign(VAlign_Center)
                    .Padding(12.0f, 2.0f, 2.0f, 2.0f)
                    [
                        SNew(SHorizontalBox)
                        .Visibility_Lambda([this]()
                        {
                            return ShouldShowInstancingIcon() ? EVisibility::Visible : EVisibility::Collapsed;
                        })
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(TEXT("◇")))
                            .Font(FCoreStyle::GetDefaultFontStyle("Bold", 12))
                            .ColorAndOpacity(FLinearColor::Blue)
                            .ToolTipText(FText::FromString(TEXT("CDO: Uses Class Default Object")))
                        ]
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        .Padding(4.0f, 0.0f, 0.0f, 0.0f)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(TEXT("CDO")))
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 8))
                            .ColorAndOpacity(FLinearColor(0.8f, 0.8f, 0.8f))
                        ]
                    ]
                ]
            ];
        }
    }
}

auto
    SCk_GraphNode_EntityScript::
    ShouldShowInstancingIcon() const
    -> bool
{
    if (ck::IsValid(_EntityScriptNode))
    {
        if (const auto& EntityScriptClass = _EntityScriptNode->DoGet_EntityScriptClass();
            ck::IsValid(EntityScriptClass))
        {
            const auto& EntityScriptCDO = UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
            const auto& InstancingPolicy = EntityScriptCDO->Get_InstancingPolicy();

            return InstancingPolicy == ECk_EntityScript_InstancingPolicy::NotInstanced;
        }
    }

    return false;
}

// --------------------------------------------------------------------------------------------------------------------

auto
    FCk_EntityScriptNode_DetailsCustomization::
    MakeInstance()
    -> TSharedRef<IDetailCustomization>
{
    return MakeShareable(new FCk_EntityScriptNode_DetailsCustomization);
}

auto
    FCk_EntityScriptNode_DetailsCustomization::
    CustomizeDetails(
        IDetailLayoutBuilder& DetailBuilder)
    -> void
{
    UE_LOG(LogTemp, Warning, TEXT("FCk_EntityScriptNode_DetailsCustomization::CustomizeDetails called!"));

    TArray<TWeakObjectPtr<UObject>> SelectedObjects;
    DetailBuilder.GetObjectsBeingCustomized(SelectedObjects);

    UE_LOG(LogTemp, Warning, TEXT("Selected objects count: %d"), SelectedObjects.Num());

    if (SelectedObjects.Num() != 1)
    {
        UE_LOG(LogTemp, Warning, TEXT("Wrong number of selected objects"));
        return;
    }

    auto* EntityScriptNode = Cast<UCk_K2Node_EntityScript>(SelectedObjects[0].Get());
    if (ck::Is_NOT_Valid(EntityScriptNode))
    {
        UE_LOG(LogTemp, Warning, TEXT("Failed to cast to UCk_K2Node_EntityScript"));
        if (SelectedObjects[0].IsValid())
        {
            UE_LOG(LogTemp, Warning, TEXT("Object class: %s"), *SelectedObjects[0]->GetClass()->GetName());
        }
        return;
    }

    UE_LOG(LogTemp, Warning, TEXT("Successfully got EntityScript node!"));

    _CachedNode = EntityScriptNode;

    UE_LOG(LogTemp, Warning, TEXT("Added test category"));

    // Continue with interface logic only if basic test works...
    auto* EntityScriptClass = EntityScriptNode->DoGet_EntityScriptClass();
    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        UE_LOG(LogTemp, Warning, TEXT("No EntityScript class found"));
        return;
    }

    const auto& ImplementedInterfaces = EntityScriptNode->GetImplementedInterfaces();
    UE_LOG(LogTemp, Warning, TEXT("Found %d implemented interfaces"), ImplementedInterfaces.Num());

    if (ImplementedInterfaces.Num() == 0)
    {
        UE_LOG(LogTemp, Warning, TEXT("No interfaces implemented"));
        return;
    }

    // Create a new category for interface navigation
    auto& InterfaceCategory = DetailBuilder.EditCategory(
        "Interface Functions",
        FText::FromString(TEXT("Interface Functions")),
        ECategoryPriority::Important);

    // Add a header
    InterfaceCategory.AddCustomRow(FText::FromString(TEXT("Interface Functions Header")))
    .WholeRowContent()
    [
        SNew(STextBlock)
        .Text(FText::FromString(TEXT("Implemented Interface Functions")))
        .Font(FCoreStyle::GetDefaultFontStyle("Bold", 10))
        .ColorAndOpacity(FLinearColor(0.8f, 0.8f, 1.0f))
    ];

    // Create scrollable area for interfaces
    InterfaceCategory.AddCustomRow(FText::FromString(TEXT("Interface Functions List")))
    .WholeRowContent()
    [
        SNew(SBox)
        .MaxDesiredHeight(200.0f)
        [
            SNew(SScrollBox)
            .Orientation(Orient_Vertical)
            + SScrollBox::Slot()
            [
                SNew(SVerticalBox)
                + SVerticalBox::Slot()
                .AutoHeight()
                [
                    CreateInterfaceFunctionWidget()
                ]
            ]
        ]
    ];
}

auto
    FCk_EntityScriptNode_DetailsCustomization::
    CreateInterfaceFunctionWidget()
    -> TSharedRef<SWidget>
{
    auto MainVerticalBox = SNew(SVerticalBox);

    if (ck::Is_NOT_Valid(_CachedNode.Get()))
    { return MainVerticalBox; }

    const auto& ConnectedInterfaces = _CachedNode->GetImplementedInterfaces();

    for (auto* InterfaceClass : ConnectedInterfaces)
    {
        if (ck::Is_NOT_Valid(InterfaceClass))
        { continue; }

        const auto& Functions = _CachedNode.IsValid() ?
            _CachedNode->GetInterfaceFunctions(InterfaceClass) : TArray<UFunction*>{};

        if (Functions.Num() == 0)
        { continue; }

        // Interface header
        MainVerticalBox->AddSlot()
        .AutoHeight()
        .Padding(0.0f, 4.0f, 0.0f, 2.0f)
        [
            SNew(SBorder)
            .BorderImage(FAppStyle::GetBrush("DetailsView.CategoryTop"))
            .Padding(6.0f, 2.0f)
            [
                SNew(STextBlock)
                .Text(FText::FromString(ck::Format_UE(TEXT("🔌 {}"), InterfaceClass->GetName())))
                .Font(FCoreStyle::GetDefaultFontStyle("Bold", 9))
                .ColorAndOpacity(FLinearColor(0.7f, 0.9f, 1.0f))
            ]
        ];

        // Function buttons
        for (auto* Function : Functions)
        {
            if (ck::Is_NOT_Valid(Function))
            { continue; }

            const auto& IsImplemented = _CachedNode->IsFunctionImplemented(Function);
            const auto& IsEvent = Function->HasAnyFunctionFlags(FUNC_BlueprintEvent);

            // Choose better icons
            FString IconText;
            if (IsEvent)
            {
                IconText = TEXT("⚡"); // Lightning bolt for events
            }
            else
            {
                IconText = TEXT("🔧"); // Wrench for functions
            }

            MainVerticalBox->AddSlot()
            .AutoHeight()
            .Padding(8.0f, 1.0f, 0.0f, 1.0f)
            [
                SNew(SHorizontalBox)
                + SHorizontalBox::Slot()
                .FillWidth(1.0f)
                [
                    SNew(SButton)
                    .ButtonStyle(FAppStyle::Get(), "FlatButton")
                    .ForegroundColor(FSlateColor::UseForeground())
                    .OnClicked(this, &FCk_EntityScriptNode_DetailsCustomization::OnNavigateToFunction, Function)
                    .ToolTipText(FText::FromString(ck::Format_UE(
                        TEXT("{}{} {}"),
                        IsImplemented ? TEXT("Navigate to ") : TEXT("Implement "),
                        IsEvent ? TEXT("event") : TEXT("function"),
                        Function->GetName())))
                    .Content()
                    [
                        SNew(SHorizontalBox)
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        .Padding(0.0f, 0.0f, 6.0f, 0.0f)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(IconText))
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 10))
                        ]
                        + SHorizontalBox::Slot()
                        .FillWidth(1.0f)
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(Function->GetName()))
                            .Font(FCoreStyle::GetDefaultFontStyle("Regular", 9))
                            .ColorAndOpacity(IsImplemented ?
                                FLinearColor(1.0f, 1.0f, 1.0f) :
                                FLinearColor(0.2f, 0.2f, 0.2f))
                        ]
                        + SHorizontalBox::Slot()
                        .AutoWidth()
                        .VAlign(VAlign_Center)
                        [
                            SNew(STextBlock)
                            .Text(FText::FromString(IsImplemented ? TEXT("🔍") : TEXT("+")))
                            .Font(FCoreStyle::GetDefaultFontStyle("Bold", 12))
                            .ColorAndOpacity(IsImplemented ?
                                FLinearColor(0.4f, 0.8f, 0.4f) :  // Green for implemented
                                FLinearColor(0.8f, 0.6f, 0.2f))   // Orange for not implemented
                            .ToolTipText(FText::FromString(IsImplemented ?
                                TEXT("Click to navigate to implementation") :
                                TEXT("Click to implement this function")))
                        ]
                    ]
                ]
            ];
        }
    }

    return MainVerticalBox;
}

auto
    FCk_EntityScriptNode_DetailsCustomization::
    OnNavigateToFunction(
        UFunction* Function)
    -> FReply
{
    if (ck::Is_NOT_Valid(_CachedNode.Get()) || ck::Is_NOT_Valid(Function))
    { return FReply::Handled(); }

    if (const bool IsImplemented = _CachedNode->IsFunctionImplemented(Function))
    {
        // Navigate to existing implementation
        _CachedNode->NavigateToInterfaceFunction(Function);
    }
    else
    {
        // Try to implement the function
        if (_CachedNode->ImplementInterfaceFunction(Function))
        {
            // Show success notification
            auto NotificationInfo = FNotificationInfo(
                FText::FromString(ck::Format_UE(TEXT("Successfully implemented: {}"), Function->GetName())));
            NotificationInfo.ExpireDuration = 3.0f;
            NotificationInfo.bFireAndForget = true;
            NotificationInfo.Image = FAppStyle::GetBrush(TEXT("Icons.SuccessWithColor"));
            FSlateNotificationManager::Get().AddNotification(NotificationInfo);

            // Navigate to the newly created implementation
            FTimerHandle TimerHandle;
            GEditor->GetTimerManager()->SetTimer(TimerHandle, [this, Function]()
            {
                if (_CachedNode.IsValid())
                {
                    _CachedNode->NavigateToInterfaceFunction(Function);
                }
            }, 0.1f, false); // Small delay to let the blueprint refresh
        }
        else
        {
            // Show error notification
            auto NotificationInfo = FNotificationInfo(
                FText::FromString(ck::Format_UE(TEXT("Failed to implement: {}"), Function->GetName())));
            NotificationInfo.ExpireDuration = 5.0f;
            NotificationInfo.bFireAndForget = true;
            NotificationInfo.Image = FAppStyle::GetBrush(TEXT("Icons.ErrorWithColor"));
            FSlateNotificationManager::Get().AddNotification(NotificationInfo);
        }
    }

    return FReply::Handled();
}

#undef LOCTEXT_NAMESPACE