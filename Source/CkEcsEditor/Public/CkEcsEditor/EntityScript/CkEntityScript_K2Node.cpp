#include "CkEntityScript_K2Node.h"

#include "CkCore/IO/CkIO_Utils.h"
#include "CkCore/Object/CkObject_Utils.h"
#include "CkCore/Reflection/CkReflection_Utils.h"

#include "CkEcs/EntityScript/CkEntityScript.h"
#include "CkEcs/EntityScript/CkEntityScript_Utils.h"
#include "CkEcs/Subsystem/CkEcsWorld_Subsystem.h"
#include "CkEcs/Subsystem/CkEntityScript_Subsystem.h"

#include <GraphEditorSettings.h>
#include <K2Node_MakeStruct.h>
#include <Kismet/GameplayStatics.h>
#include <StructUtilsFunctionLibrary.h>
#include <Kismet2/BlueprintEditorUtils.h>
#include <K2Node_CallFunction.h>
#include <K2Node_MakeStruct.h>

#define LOCTEXT_NAMESPACE "UCk_K2Node_EntityScript"

// --------------------------------------------------------------------------------------------------------------------

// ReSharper disable once CppInconsistentNaming
namespace ck_k2node_entity_script
{
    static auto PinName_LifetimeOwner = TEXT("InLifetimeOwner");
    static auto PinName_Class  = TEXT("InEntityScriptClass");
    static auto PinName_LifetimeOwnerType  = TEXT("InLifetimeOwnerType");
    static auto PinName_ReturnValue  = TEXT("EntityUnderConstruction");
}

auto
    UCk_K2Node_EntityScript::
    DoCreatePinsFromEntityScript(
        UClass* InEntityScriptClass)
    -> void
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return; }

    _PinsGeneratedForEntityScript.Empty();

    const auto& CreatePinFromProperty = [this](const FProperty* InProperty, UObject* InContainer)
    {
        auto* Pin = CreatePin(EGPD_Input, NAME_None, InProperty->GetFName());
        _PinsGeneratedForEntityScript.Add(Pin);

        if (ck::Is_NOT_Valid(Pin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        Pin->PinFriendlyName = InProperty->GetDisplayNameText();
        const auto* K2Schema = GetDefault<UEdGraphSchema_K2>();

        K2Schema->ConvertPropertyToPinType(InProperty, Pin->PinType);

        if (K2Schema->PinDefaultValueIsEditable(*Pin))
        {
            auto DefaultValueAsString = FString{};
            const auto& DefaultValueSet = FBlueprintEditorUtils::PropertyValueToString(InProperty, reinterpret_cast<const uint8*>(InContainer), DefaultValueAsString, this);
            check(DefaultValueSet);

            K2Schema->SetPinAutogeneratedDefaultValue(Pin, DefaultValueAsString);
        }
        else if (const auto* StructProperty = CastField<FStructProperty>(InProperty);
                 ck::IsValid(StructProperty))
        {
            if (const auto* StructData = InProperty->ContainerPtrToValuePtr<uint8>(InContainer))
            {
                FString DefaultStructValue;
                StructProperty->Struct->ExportText(
                    DefaultStructValue,
                    StructData,
                    StructData,
                    InContainer,
                    PPF_None,
                    nullptr);

                K2Schema->TrySetDefaultValue(*Pin, DefaultStructValue);
            }
        }

        K2Schema->ConstructBasicPinTooltip(*Pin, InProperty->GetToolTipText(), Pin->PinToolTip);
    };

    auto* ConstructionScriptCDO = InEntityScriptClass->GetDefaultObject();

    for (const auto* ExposedProperty : UCk_Utils_Reflection_UE::Get_ExposedPropertiesOfClass(InEntityScriptClass))
    {
        CreatePinFromProperty(ExposedProperty, ConstructionScriptCDO);
    }
}

auto
    UCk_K2Node_EntityScript::
    DoOnClassPinChanged()
    -> void
{
    TArray<UEdGraphPin*> OldPins = Pins;
    TArray<UEdGraphPin*> OldClassPins;

    for (auto* OldPin : OldPins)
    {
        if (NOT _PinsGeneratedForEntityScript.Contains(OldPin))
        { continue; }

        Pins.Remove(OldPin);
        OldClassPins.Add(OldPin);
    }

    TArray<UEdGraphPin*> NewClassPins;

    if (auto* ClassToSpawn = DoGet_EntityScriptClass(Pins);
        ck::IsValid(ClassToSpawn))
    {
        DoCreatePinsFromEntityScript(ClassToSpawn);
    }

    RestoreSplitPins(OldPins);
    RewireOldPinsToNewPins(OldClassPins, Pins, nullptr);
    GetGraph()->NotifyGraphChanged();
    FBlueprintEditorUtils::MarkBlueprintAsModified(GetBlueprint());
}

auto
    UCk_K2Node_EntityScript::
    IsNodePure() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    ReallocatePinsDuringReconstruction(
        TArray<UEdGraphPin*>& InOldPins)
    -> void
{
    for (const auto Pin : InOldPins)
    {
        if (Pin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
        {
            const auto EnumValue = UCk_Utils_Enum_UE::Get_EnumFromString<ECk_EntityLifetime_OwnerType>(Pin->DefaultValue);
            CK_ENSURE_IF_NOT(ck::IsValid(EnumValue),
                TEXT("Failed to get Enum value from string [{}]. This should have worked. Some EntityScript Spawn nodes in the graph [{}] might be faulty."),
                Pin->DefaultValue, this->GetGraph())
            { break; }

            _LifetimeOwnerType = *EnumValue;
            break;
        }
    }

    // Now proceed with standard pin reallocation
    AllocateDefaultPins();

    // Get entity script class from old pins
    if (auto* EntityScriptClass = DoGet_EntityScriptClass(InOldPins))
    {
        DoCreatePinsFromEntityScript(EntityScriptClass);
    }

    RestoreSplitPins(InOldPins);
}

auto
    UCk_K2Node_EntityScript::
    ShouldShowNodeProperties() const
    -> bool
{
    return false;
}

auto
    UCk_K2Node_EntityScript::
    GetNodeTitle(
        ENodeTitleType::Type InTitleType) const
    -> FText
{
    if (const auto& EntityScriptClass = DoGet_EntityScriptClass();
        ck::IsValid(EntityScriptClass))
    {
        const auto& EntityScriptCDO =  UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
        const auto& Replication = EntityScriptCDO->Get_Replication();
        const auto& InstancingPolicy = EntityScriptCDO->Get_InstancingPolicy();

        return CK_UTILS_IO_GET_LOCTEXT
        (
            TEXT("UCk_K2Node_EntityScript"),
            *ck::Format_UE(TEXT("[Ck] Request Spawn Entity {}{}\n({})"),
                Replication == ECk_Replication::Replicates ? TEXT("(REPLICATED)" : TEXT("")),
                InstancingPolicy == ECk_EntityScript_InstancingPolicy::NotInstanced ? TEXT("(Uses CDO)" : TEXT("")),
                EntityScriptClass->GetDisplayNameText())
        );
    }

    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Request Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    GetIconAndTint(
        FLinearColor& OutColor) const
    -> FSlateIcon
{
    OutColor = GetDefault<UGraphEditorSettings>()->FunctionCallNodeTitleColor;
    return FSlateIcon(FAppStyle::GetAppStyleSetName(), TEXT("Kismet.AllClasses.FunctionIcon"));
}

auto
    UCk_K2Node_EntityScript::
    GetMenuCategory() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("Ck|EntityScript")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoAllocate_DefaultPins()
    -> void
{
    using namespace ck_k2node_entity_script;

    CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Class,
        UCk_EntityScript_UE::StaticClass(),
        PinName_Class
    );

    auto* LifetimeOwnerTypeEnumPin =  CreatePin
    (
        EGPD_Input,
        UEdGraphSchema_K2::PC_Byte,
        StaticEnum<ECk_EntityLifetime_OwnerType>(),
        PinName_LifetimeOwnerType
    );

    auto* ReturnValuePin = CreatePin
    (
        EGPD_Output,
        UEdGraphSchema_K2::PC_Struct,
        FCk_Handle_PendingEntityScript::StaticStruct(),
        PinName_ReturnValue
    );
    ReturnValuePin->PinToolTip = TEXT("The handle to the newly spawned Entity (not yet constructed)");

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseCustomEntity)
    {
        CreatePin(
            EGPD_Input,
            UEdGraphSchema_K2::PC_Struct,
            FCk_Handle::StaticStruct(),
            PinName_LifetimeOwner
        );
    }

    const UEdGraphSchema_K2* Schema = GetDefault<UEdGraphSchema_K2>();
    Schema->SetPinAutogeneratedDefaultValueBasedOnType(LifetimeOwnerTypeEnumPin);

    DoCreatePinsFromEntityScript(DoGet_EntityScriptClass());
}

auto
    UCk_K2Node_EntityScript::
    IsCompatibleWithGraph(
        UEdGraph const* InGraph) const
    -> bool
{
    return Super::IsCompatibleWithGraph(InGraph);
}

auto
    UCk_K2Node_EntityScript::
    PinConnectionListChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::PinConnectionListChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        DoOnClassPinChanged();
    }
}

auto
    UCk_K2Node_EntityScript::
    GetPinMetaData(
        FName InPinName,
        FName InKey)
    -> FString
{
    if (InPinName == ck_k2node_entity_script::PinName_Class && InKey == FBlueprintMetadata::MD_AllowAbstractClasses)
    { return TEXT("False"); }

    return Super::GetPinMetaData(InPinName, InKey);
}

auto
    UCk_K2Node_EntityScript::
    GetJumpTargetForDoubleClick() const
    -> UObject*
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    { return Super::GetJumpTargetForDoubleClick(); }

    return UCk_Utils_Object_UE::Get_ClassGeneratedByBlueprint(EntityScriptClass);
}

auto
    UCk_K2Node_EntityScript::
    ValidateNodeDuringCompilation(
        class FCompilerResultsLog& MessageLog) const
    -> void
{
    Super::ValidateNodeDuringCompilation(MessageLog);

    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        MessageLog.Error(*LOCTEXT("Missing Entity Script", "Invalid Entity Script. @@").ToString(), this);
        return;
    }

    if (EntityScriptClass == UCk_EntityScript_UE::StaticClass())
    {
        MessageLog.Error(*LOCTEXT("Trying to Spawn Base Entity Script", "Cannot Spawn Base Entity Script. @@").ToString(), this);
        return;
    }

    const auto& EntityScriptCDO =  UCk_Utils_Object_UE::Get_ClassDefaultObject<UCk_EntityScript_UE>(EntityScriptClass);
    const auto& Replication = EntityScriptCDO->Get_Replication();

    if (const auto& LifetimeOwnerType = DoGet_LifetimeOwnerType();
        LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseTransientEntity && Replication == ECk_Replication::Replicates)
    {
        MessageLog.Error(*LOCTEXT("Trying to Spawn Replicated Entity Script with Transient Entity as the LifetimeOwner",
            "Cannot Spawn Replicated Entity Script with Transient Entity as the LifetimeOwner @@").ToString(), this);
        return;
    }
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntitySpawnParamsStruct(
        UClass* InEntityScriptClass,
        FKismetCompilerContext& InCompilerContext)
        -> UScriptStruct*
{
    if (ck::Is_NOT_Valid(InEntityScriptClass))
    { return {}; }

    auto* EntityScriptSubsystem = GEngine->GetEngineSubsystem<UCk_EntityScript_Subsystem_UE>();
    if (ck::Is_NOT_Valid(EntityScriptSubsystem))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to get Entity Script Subsystem"));
        return {};
    }

    auto* SpawnParamsStruct = EntityScriptSubsystem->GetOrCreate_SpawnParamsStructForEntity(InEntityScriptClass);
    if (ck::Is_NOT_Valid(SpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(TEXT("Failed to find valid Spawn Params struct for Entity Script [{}]"), InEntityScriptClass);
        return {};
    }

    return SpawnParamsStruct;
}

auto
    UCk_K2Node_EntityScript::
    DoExpandNode(
        FKismetCompilerContext& InCompilerContext,
        UEdGraph* InSourceGraph,
        ECk_ValidInvalid InNodeValidity)
    -> void
{
    const auto& EntityScriptClass = DoGet_EntityScriptClass();

    if (ck::Is_NOT_Valid(EntityScriptClass))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script", "Invalid Entity Script. @@").ToString(), this);
        return;
    }

    if (EntityScriptClass == UCk_EntityScript_UE::StaticClass())
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Trying to Spawn Base Entity Script", "Cannot Spawn Base Entity Script. @@").ToString(), this);
        return;
    }

    _LifetimeOwnerType = DoGet_LifetimeOwnerType();

    auto* EntitySpawnParamsStruct = DoGet_EntitySpawnParamsStruct(EntityScriptClass, InCompilerContext);

    if (ck::Is_NOT_Valid(EntitySpawnParamsStruct))
    {
        InCompilerContext.MessageLog.Error(*LOCTEXT("Missing Entity Script Spawn Params struct", "Invalid Entity Script Spawn Params struct @@").ToString(), this);
        return;
    }

    // Create a Make Struct node for the Spawn Params
    auto* MakeSpawnParamsStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_MakeStruct>(this, InSourceGraph);
    MakeSpawnParamsStruct_Node->StructType = EntitySpawnParamsStruct;
    MakeSpawnParamsStruct_Node->bMadeAfterOverridePinRemoval = true;
    MakeSpawnParamsStruct_Node->AllocateDefaultPins();

    // Create a MakeInstancedStruct node to convert UScriptStruct to FInstancedStruct
    auto* MakeInstancedStruct_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    MakeInstancedStruct_Node->SetFromFunction(UStructUtilsFunctionLibrary::StaticClass()->FindFunctionByName(GET_FUNCTION_NAME_CHECKED(UStructUtilsFunctionLibrary, MakeInstancedStruct)));
    MakeInstancedStruct_Node->AllocateDefaultPins();

    const auto& TryCopyValueOrLinkPin = [&](UEdGraphPin* InPinToCopyOrLinkFrom)
    {
        auto* FoundMakeStructPin = MakeSpawnParamsStruct_Node->FindPinByPredicate([&](const UEdGraphPin* InPin)
        {
            return InPin->PinFriendlyName.ToString() == InPinToCopyOrLinkFrom->PinName.ToString();
        });

        if (ck::Is_NOT_Valid(FoundMakeStructPin, ck::IsValid_Policy_NullptrOnly{}))
        { return; }

        if (NOT InPinToCopyOrLinkFrom->DefaultValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultValue = InPinToCopyOrLinkFrom->DefaultValue;
        }

        if (ck::IsValid(InPinToCopyOrLinkFrom->DefaultObject))
        {
            FoundMakeStructPin->DefaultObject = InPinToCopyOrLinkFrom->DefaultObject;
        }

        if (NOT InPinToCopyOrLinkFrom->DefaultTextValue.IsEmpty())
        {
            FoundMakeStructPin->DefaultTextValue = InPinToCopyOrLinkFrom->DefaultTextValue;
        }

        if (NOT InPinToCopyOrLinkFrom->LinkedTo.IsEmpty())
        {
            for (auto* LinkedPin : InPinToCopyOrLinkFrom->LinkedTo)
            {
                InCompilerContext.GetSchema()->TryCreateConnection(LinkedPin, FoundMakeStructPin);
            }
        }
    };

    for (auto* Pin : this->Pins)
    {
        if (Pin->Direction == EGPD_Input &&
            Pin != this->GetExecPin() &&
            Pin->PinName != ck_k2node_entity_script::PinName_Class &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwnerType &&
            Pin->PinName != ck_k2node_entity_script::PinName_LifetimeOwner)
        {
            TryCopyValueOrLinkPin(Pin);
        }
    }

    // Set up 'Request_SpawnEntity' function node
    auto* SpawnEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
    SpawnEntity_Node->FunctionReference.SetExternalMember
    (
        GET_FUNCTION_NAME_CHECKED(UCk_Utils_EntityScript_UE, Request_SpawnEntity),
        UCk_Utils_EntityScript_UE::StaticClass()
    );
    SpawnEntity_Node->AllocateDefaultPins();
    InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(SpawnEntity_Node, this);

    // Connect everything together
    if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(EntitySpawnParamsStruct->GetFName(), ECk_EditorGraph_PinDirection::Output, *MakeSpawnParamsStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("Value"), ECk_EditorGraph_PinDirection::Input, *MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*SpawnEntity_Node),
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*MakeInstancedStruct_Node),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InSpawnParams"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            },
        }
    ) == ECk_SucceededFailed::Failed) { return; }

    // Link or assign entity script class
    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InEntityScriptClass"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed)
    {
        if (auto* EntityScriptClassPin = SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_Class);
            ck::IsValid(EntityScriptClassPin, ck::IsValid_Policy_NullptrOnly{}))
        {
            InCompilerContext.GetSchema()->TrySetDefaultValue(*EntityScriptClassPin, EntityScriptClass->GetClassPathName().ToString());
            UCk_Utils_EditorGraph_UE::Request_ForceRefreshNode(*SpawnEntity_Node);
        }
    }

    if (UCk_Utils_EditorGraph_UE::Request_LinkPins
    (
        InCompilerContext,
        {
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Exec(*MakeInstancedStruct_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Then(*SpawnEntity_Node)
            },
            {
                UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_ReturnValue, ECk_EditorGraph_PinDirection::Output, *this),
                UCk_Utils_EditorGraph_UE::Get_Pin_Result(*SpawnEntity_Node)
            }
        },
        ECk_EditorGraph_PinLinkType::Move
    ) == ECk_SucceededFailed::Failed) { return; }

    if (_LifetimeOwnerType == ECk_EntityLifetime_OwnerType::UseTransientEntity)
    {
        // Set up 'Get_TransientEntity' function node
        auto* GetTransientEntity_Node = InCompilerContext.SpawnIntermediateNode<UK2Node_CallFunction>(this, InSourceGraph);
        GetTransientEntity_Node->FunctionReference.SetExternalMember
        (
            GET_FUNCTION_NAME_CHECKED(UCk_Utils_EcsWorld_Subsystem_UE, Get_TransientEntity_FromContextObject),
            UCk_Utils_EcsWorld_Subsystem_UE::StaticClass()
        );
        GetTransientEntity_Node->AllocateDefaultPins();
        InCompilerContext.MessageLog.NotifyIntermediateObjectCreation(GetTransientEntity_Node, this);

        if (UCk_Utils_EditorGraph_UE::Request_TryCreateConnection
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin_Result(*GetTransientEntity_Node),
                    UCk_Utils_EditorGraph_UE::Get_Pin(TEXT("InLifetimeOwner"), ECk_EditorGraph_PinDirection::Input, *SpawnEntity_Node)
                },
            }
        ) == ECk_SucceededFailed::Failed) { return; }
    }
    else
    {
        if (UCk_Utils_EditorGraph_UE::Request_LinkPins
        (
            InCompilerContext,
            {
                {
                    UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_LifetimeOwner, ECk_EditorGraph_PinDirection::Input, *this),
                    SpawnEntity_Node->FindPin(ck_k2node_entity_script::PinName_LifetimeOwner, EGPD_Input)
                },
            },
            ECk_EditorGraph_PinLinkType::Move
        ) == ECk_SucceededFailed::Failed) { return; }
    }

    BreakAllNodeLinks();
}

auto
    UCk_K2Node_EntityScript::
    DoGet_Menu_NodeTitle() const
    -> FText
{
    return CK_UTILS_IO_GET_LOCTEXT
    (
        TEXT("UCk_K2Node_EntityScript"),
        TEXT("[Ck] Spawn Entity")
    );
}

auto
    UCk_K2Node_EntityScript::
    DoPinDefaultValueChanged(
        UEdGraphPin* InPin)
    -> void
{
    Super::DoPinDefaultValueChanged(InPin);

    if (ck::Is_NOT_Valid(InPin, ck::IsValid_Policy_NullptrOnly{}))
    { return; }

    if (InPin->PinName == ck_k2node_entity_script::PinName_LifetimeOwnerType)
    {
        if (const auto NewLifetimeOwnerType = DoGet_LifetimeOwnerType();
            _LifetimeOwnerType != NewLifetimeOwnerType)
        {
            _LifetimeOwnerType = NewLifetimeOwnerType;
            ReconstructNode();
        }
        return;
    }

    if (InPin->PinName == ck_k2node_entity_script::PinName_Class)
    {
        auto* EntityScriptClass = Cast<UClass>(InPin->DefaultObject);

        const auto& CheckPinValidity = [&]() -> ECk_SucceededFailed
        {
            if (ck::Is_NOT_Valid(EntityScriptClass))
            { return ECk_SucceededFailed::Failed; }

            CK_ENSURE_IF_NOT(NOT EntityScriptClass->HasAnyClassFlags(_DisallowedFlags), TEXT("The DefaultObject in the [{}] pin cannot be an Abstract/Deprecated/None class."), InPin->PinName)
            { return ECk_SucceededFailed::Failed; }

            return ECk_SucceededFailed::Succeeded;
        };

        if (CheckPinValidity() == ECk_SucceededFailed::Failed)
        {
            InPin->DefaultObject = nullptr;
        }

        DoOnClassPinChanged();
        return;
    }
}

auto
    UCk_K2Node_EntityScript::
    DoGet_EntityScriptClass(
        TOptional<TArray<UEdGraphPin*>> InPinsToSearch) const
    -> UClass*
{
    if (ck::Is_NOT_Valid(InPinsToSearch))
    {
        InPinsToSearch = Pins;
    }

    const auto& ClassPin = UCk_Utils_EditorGraph_UE::Get_Pin(ck_k2node_entity_script::PinName_Class, ECk_EditorGraph_PinDirection::Input, *InPinsToSearch);

    if (ck::Is_NOT_Valid(ClassPin))
    { return {}; }

    const auto& ClassPinCDO = (*ClassPin)->DefaultObject;
    const auto& ClassPinLinkedTo = (*ClassPin)->LinkedTo;

    if (ClassPinLinkedTo.Num() == 0)
    {
        return ck::IsValid(ClassPinCDO) ? CastChecked<UClass>(ClassPinCDO) : nullptr;
    }

    const auto& ClassSource = ClassPinLinkedTo[0];
    return  ClassSource ? Cast<UClass>(ClassSource->PinType.PinSubCategoryObject.Get()) : nullptr;
}

auto
    UCk_K2Node_EntityScript::
    DoGet_LifetimeOwnerType() const
    -> ECk_EntityLifetime_OwnerType
{
    return *UCk_Utils_EditorGraph_UE::Get_Pin_EnumValue<ECk_EntityLifetime_OwnerType>(
        ck_k2node_entity_script::PinName_LifetimeOwnerType, ECk_EditorGraph_PinDirection::Input, *this);
}

#undef LOCTEXT_NAMESPACE